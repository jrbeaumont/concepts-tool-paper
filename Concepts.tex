
%\documentclass[british, journal]{IEEEtran}
\documentclass[british,conference,compsoc]{IEEEtran}
\usepackage[T1]{fontenc}
%\usepackage[latin9]{inputenc}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{array}
\usepackage{blindtext}

\makeatletter

\newcommand{\noun}[1]{\textsc{#1}}

\@ifundefined{showcaptionsetup}{}{
 \PassOptionsToPackage{caption=false}{subfig}}
\usepackage{subfig}
\makeatother

\usepackage{babel}
\usepackage{algpseudocode}
\usepackage{algorithm}

\begin{document}

\twocolumn

\title{Automated translation of asynchronous concepts \\
to Signal Transition Graphs}
\author{Jonathan Beaumont\\
\texttt{j.r.beaumont@ncl.ac.uk}\\
\emph{School of Electrical and Electronic Engineering, Newcastle University,
UK}}

\maketitle

%\begin{abstract}
%Asynchronous circuits are becoming increasingly important in
%system design for Internet-of-Things, where they orchestrate
%the interface between big synchronous computation components
%and the analogue environment, which is inherently asynchronous
%and has high uncertainty with respect to power supply,
%temperature and long-term ageing effects.
%However, wide adoption of asynchronous circuits by industrial users is
%hindered by a steep learning curve for asynchronous control models,
%such as Signal Transition Graphs, that are developed by the academic
%community for specification, verification and synthesis of
%asynchronous circuits.
%
%Previously, we have introduced a novel high-level description language
%for asynchronous circuits, which is based on behavioural
%\textit{concepts} -- high-level descriptions of asynchronous circuit
%requirements, that can be shared, reused and extended by users. 
%In this paper we will discuss more examples using concepts, and an algorithm to
%automatically translate these to Signal Transition Graphs for further processing
%by conventional asynchronous and synchronous EDA tools, such as \noun{Petrify}
%and \noun{Mpsat}. Our aim is to simplify the process of capturing system
%requirements in the form of a formal specification, and to promote behavioural
%concepts as a means for design reuse. The proposed design flow is fully
%automated in open-source toolsuite \noun{Workcraft}.
%\end{abstract}

\sloppy
\thispagestyle{empty}
%%\vspace{-3mm}
\section{Introduction}

\emph{Concepts} have been presented in order to provide a more compact, adaptive and intuitive method of
designing asynchronous circuits, using a fully compositional text based description method. 
This was born out of the use of algebra for designing systems,
such as the model Conditional Partial Order Graphs~\cite{CPOG1}\cite{CPOG2}\cite{2014_mokhov_pg},
the algebra of switching networks~\cite{mokhov2015algebra}. Composition is an important part of concepts
 and the use of composition in some algebraic representations, such as with DI algebra~\cite{270632} 
 and Conditional Signal Graphs~\cite{6243877} helped to inspire this. 

As discussed in~\cite{2015_Beaumont_MEMOCODE}, concepts are a useful language for specifying
the behaviours of asynchronous circuits, in the preferred form of the user. This can be as low-level 
signal-level concepts, or higher-level gate- or protocol-level concepts. It also allows the definition of 
their own concepts, which can be reused within the same or any other specification that they wish
to increase the speed of designing a system, and future systems. 

With concepts, we aim to solve the problems that can arise from the more commonly used
monolithic approach, where a user must design each system in the form of an STG from a blank page. 
The scalability of this is poor: as the system grows in complexity its monolithic specification becomes 
challenging to comprehend and debug. The problem becomes particularly severe when designing 
multi-mode systems, such as power regulators, where capturing all aspects of system behaviour in a
consistent specification is a major design challenge~\cite{2014_sokolov_ftfc}\cite{sokolov2015design}. 
Moreover, the STG models of components and  operating modes are difficult to reuse when designing 
other specifications, and thus each new design must be built from the ground up. This is particularly 
undesirable for industry, as this increases the design time of each design greatly. 

%We have also displayed a design flow with the example of a buck controller, where a specification is 
%split into \textit{scenarios}, each representing a different operational mode of the system. 
%Each one is composed of concepts, and many of these concepts can be reused between 
%scenarios.

STGs~\cite{Chu_1987_phd}\cite{Rosenblum_1985_tpn}
are commonly used for the specification,
verification and synthesis of asynchronous control circuits as they are
supported by multiple EDA tools, such as \noun{Petrify}~\cite{Cortadella},
\noun{Mpsat}~\cite{khomenko2004detecting}, \noun{Versify}~\cite{i1997formal},
\noun{Workcraft}~\cite{2007_poliakov_workcraft}\cite{Workcraft_website}, and
others.
These tools take an STG specification of a complete controller and can
formally verify its correctness, as well as synthesise an asynchronous
circuit implementation that is \emph{speed-independent}, i.e. guaranteed
to work correctly regardless of component delays~\cite{Muller_1959_ts}.

Concepts are not supported by these tools, and rather than reinvent the wheel by authoring tools
to verify and synthesize concepts directly, we can \emph{translate} concepts to STGs, for use with 
these existing tools. Previously, we have introduced a prototype algorithm for translating concepts
to STGs. However, this version would not allow for some important features of circuits to be
translated. 

In this paper we display all concept types necessary for a complete specification, and some 
example concept specifications. These will display the possibilities of concepts, as well as the 
problems with the prototype translation algorithm, namely \emph{OR-causality}, which is 
much more complex than AND-causality which is standard within concepts. 
This will lead us to a new translation algorithm, which has been implemented as a tool. 
%along with the domain specific language~\cite{2016_concepts_github} embedded in 
%Haskell~\cite{1996_hudak_dsl}, and integrated into 
%\noun{Workcraft}~\cite{Workcraft_website}, an open-source EDA tool which also 
%features some verification and synthesis tools for STGs. 

Our contributions are as follows:
\begin{itemize}
  \item We detail the concepts required for a successful  
  translation in Section~\ref{sec:trans-concepts}
  \item We introduce some new gate examples and their specifications in
  Section~\ref{sec:examples}, presenting what can be acheived with
  concepts, and how OR-causality becomes necessary in specifications.
  \item We present the implemented algorithm for translating concepts to STGs
  including OR-causality in Section~\ref{sec:algorithm}.
\end{itemize}

\noindent
We start with a brief recap of asynchronous concepts as a specification language in
Section~\ref{sec:async-concepts}, and discuss the interoperability of the provided tool 
with existing standard STG based tools in Section~\ref{sub:interop-with-stg}.

%Analogue and mixed-signal circuits become more tightly integrated with
%digital systems, in particular in mobile and autonomous applications,
%such as wearable consumer electronics and self-powered Internet-of-Things
%nodes, where it is essential to have intelligent timing control and power
%regulation~\cite{7287733}\cite{talbot2016holistic}\cite{6241632}.
%An on-chip power management system is an illustrative example: it relies
%on analogue circuitry for power regulation and conversion, and its behaviour
%is characterised by many operating modes with complex interplay and
%high-level decision logic that is digitally controlled.
%Asynchronous circuits are event-driven, i.e. they react to changes
%in a system at the rate they occur~\cite{sparso2001principles}.
%This makes them particularly useful for interacting with analogue world,
%where the ability to quickly respond to non-digital input, e.g.
%dynamically changing loads across the chip, is essential for reliable
%operation and efficiency~\cite{2008_audy_isscc_tutorial}.

%The method splits a specification into several parts corresponding
%to operational modes of the circuit (\emph{scenarios}). The features,
%constraints and requirements of each scenario (\emph{concepts}),
%are described in a formal notation, which we implemented as a domain
%specific language embedded in Haskell~\cite{1996_hudak_dsl}. Concepts can
%be defined at several levels; specifically, we give examples of signal-,
%gate- and protocol-level concepts. It is possible to compose basic concepts
%into more complex ones, thus supporting the design reuse at the level of system
%specification.
%Commented out as I'm not sure we are actually talking about this in the paper:
%Scenarios of reconfigurable systems~\cite{microadapt}
%can also be parameterised by run-time parameters (e.g., available
%energy budget) or design-time ones (e.g., the number of processing
%cores in a Network-on-Chip network), therefore concepts should also
%support parameterisation.
%Concepts can be automatically translated into equivalent STGs and
%formally verified using standard tools, e.g. \noun{Workcraft}.
%When all scenarios have been translated to STGs and verified, they can be
%combined to produce a complete specification, and synthesised into an
%asynchronous circuit implementation targeting a chosen technology library.
%Commented out, as this is probably too detailed for the intro.
%This step will also be automated,
%and will offer \emph{templates} for common scenario ordering requirements,
%such as mode switching sequences and start-up scenarios.


%We start with a motivational example in Section~\ref{sec:Motivating Example},
%review related work
%in Section~\ref{sec:related-work}, and discuss future research in
%Section~\ref{sec:conclusions}.

%Designing a controller for an analogue circuit using this method can
%be beneficial. Any of the partial knowledge we have about any casual
%relationships between events in the environment can be naturally modelled
%as concepts. When composed with other concepts describing these relationships
%and concepts describing the control which reacts to the environment,
%a model will be produced which shows how the environment and the control
%system interacts.

%The idea is that our approach should reduce the complexity of designing
%asynchronous circuits, so the number of errors should be reduced,
%and easier to find and correct. This will in turn reduce the design
%time, and make asynchronous circuits more desirable for industry, so
%asynchronous circuits can be used in devices more commonly.

%The presented approach is automated as a Haskell
%tool~\cite{2016_concepts_github}.
%This parses concepts and uses them to produce scenario STGs. We aim to
%implement
%combination of scenarios in the tool in the future.
%STGs produced, either scenario or full system, are viewed,
%edited, simulated, verified and synthesised using the open-source
%\noun{Workcraft}
%framework~\cite{2007_poliakov_workcraft}, which features back-end tools
%\noun{Petrify}
%and \noun{Mpsat} to perform these operations.

%In this paper, we use real life industrial
%example of a buck converter~\cite{2014_sokolov_ftfc} to show our
%design flow, and test this design approach.
%%%\vspace{-2mm}

%\section{Motivating Example: Buck Converter\label{sec:Motivating Example}}
%
%On-chip power management is essential for energy efficiency and reliability of
%IoT computation nodes~\cite{7287733}. According to a 2016 report by
%Research~\&~Markets, the global power management market will reach
%\$34.86~billion
%by 2022, driven by the increasing demand in various applications, including
%traditional IoT sectors such as wearable, automotive, industrial, retail and
%building control electronics. Unlike conventional digital components, power
%management units need to directly interface with the analogue part of the systemfor sensing and controlling it, and can therefore strongly benefit from
%asynchronous
%implementation that allows them to react to changes in the system at the rate
%they occur, instead of sampling various analogue parameters by clock, which is
%slow and energy-wasteful~\cite{2014_sokolov_ftfc}\cite{sokolov2015design}.
%As a compelling example, consider an asynchronous power management controller
%with
%1ns response time to stimuli from the analogue world. To match its performance
%with a synchronous equivalent, one would need to clock it at 2-3GHz, as two
%clock
%cycles are required just for a conventional two flip-flop
%synchroniser~\cite{2008_kinniment_synchronisation}. Bearing in mind that
%power management controllers spend most of their time doing nothing and
%waiting for relatively slow changes in the analogue environment, such
%a high-speed clock solution would clearly be inadequate.
%
%\begin{figure}[t]
%\begin{centering}
%\subfloat[\label{fig:buck-schematic}Schematic (digital control in analogue
%environment).]
%{\includegraphics[scale=0.7]{Images/schematic-buck}}
%\par
%\subfloat[\label{fig:buck-spec}Informal description of three behavioural
%scenarios.]
%{\includegraphics[scale=0.6]{Images/spec-buck}}
%\par
%\end{centering}
%\protect\caption{\label{fig:buck}Buck converter and its informal description.}
%%%\vspace{-3mm}
%\end{figure}
%
%In this section we first provide the background on asynchronous buck
%converters Section~\ref{sub:buck}, our main motivation example and case study.
%Buck converters rely on analogue circuitry for power regulation and
%conversion and their behaviour is typically characterised by many operating
%modes with complex interplay and high-level decision logic that is digitally
%controlled.
%We then discuss challenges arising in the design of asynchronous buck converterswith Signal Transition
%Graphs~(STGs)~\cite{Chu_1987_phd}\cite{Rosenblum_1985_tpn},
%a commonly used mathematical model for the specification of asynchronous
%circuits Section~\ref{sub:Monolithic}.
%Finally, we outline our new design approach Section~\ref{sub:new-way} wherein
%the
%behaviour of an asynchronous buck converter is decomposed into simple
%behaviours, that we later refer to as \emph{concepts}. The approach is
%described at an intuitive level, and will be formalised in the next
%section, Section~\ref{sec:Concepts}.
%
%\subsection{Background on buck converters\label{sub:buck}}
%
%Our motivating example comes from the power management domain, a
%\emph{multi-scenario power regulator}~\cite{2014_sokolov_ftfc}.
%A basic power regulator comprises an analogue buck and a digital controller,
%as shown in Figure~\ref{fig:buck-schematic}. The controller operates
%the power regulating PMOS and NMOS transistors of the buck~(using \textsf{$gp$}
%and \textsf{$gn$} outputs) as a reaction to \emph{under-voltage}~(UV),
%\emph{over-current}~(OC) and \emph{zero-crossing}~(ZC)
%conditions~(\textsf{$uv$},
%\textsf{$oc$}, and \textsf{$zc$} inputs, respectively). These conditions
%are detected by a set of sensors that compare the measured current and voltage
%with some reference values~(\textsf{V\_ref}, \textsf{I\_max}, \textsf{I\_0}).
%Note that in order to avoid a shortcircuit, the PMOS and NMOS transistors of
%the buck must never be \noun{On} at the same time. Therefore, the controller
%is explicitly notified~(by \textsf{$gp\_ack$} and \textsf{$gn\_ack$})
%when the power transistor threshold levels~(\textsf{V\_pmos} and
%\textsf{V\_nmos})
%are crossed.
%
%The operation of a power regulator is usually described in an intuitive,
%but rather informal way, e.g. by enumerating the possible sequences
%of detected conditions and describing the intended reaction to these
%events, as shown in Figure~\ref{fig:buck-spec}. The diagram shows
%that UV should be handled by switching the NMOS transistor \noun{Off}
%and PMOS transistor \noun{On}, while OC should revert their state~--
%PMOS \noun{Off} and NMOS \noun{On}~(\textbf{ZC~absent} scenario). Detection of
%the ZC after UV does not change this behaviour~(\textbf{ZC~late} scenario).
%However, if ZC is detected before UV then both the PMOS and NMOS transistors
%remain \noun{Off} until the UV condition~(\textbf{ZC~early} scenario).
%
%\begin{figure}[t]
%\begin{centering}
%\includegraphics[scale=0.23]{Images/stg-buck}
%\par
%\protect\caption{\label{fig:Monolithic-buck}STG specification of a simple buck
%converter.}
%\par\end{centering}
%\end{figure}
%
%\subsection{Monolithic STG-based design approach\label{sub:Monolithic}}
%
%Using the informal description of three behavioural scenarios, the designer can
%produce a formal specification, typically a monolithic STG describing the
%complete behaviour of the circuit. Figure~\ref{fig:Monolithic-buck} shows such
%a monolithic STG specification for the simple buck controller described above.
%Nodes of the STG correspond to signal rising ($+$) and falling ($-$)
%transitions,
%arcs model \emph{causality}, parallel branches correspond to concurrency, and
%a circle \emph{place} with a black dot (\emph{token}) represents the choice of
%the current scenario. We formally introduce STGs
%in Section~\ref{sec:Circuit-specification-with}.
%
%This STG is moderately large and captures all three scenarios by overlaying
%their common parts. In the monolithic design approach, the designer starts with
%a blank page and manually inserts signal transitions and the connections betweenthem according to the informal description of the system's operation. With
%there being several scenarios, the designer could choose to design each
%separately, and then manually compose these taking advantage of the
%similarities between the scenarios, as described
%in~\cite{2014_sokolov_ftfc}\cite{sokolov2015design}.
%
%In the event that a designer needs to add or remove signals or correct a fault,
%editing can become difficult, due to the complexity and size. This can lead to
%further faults, and several iterations of design and tests until the new
%feature is added and deemed to be working correctly.
%
%A designer may even have to start from a blank page in some cases, unable to
%reuse any of the previous design. The larger and more complex an STG is, and
%the more signals there are, the more difficult it is to comprehend,
%debug and edit. This can slow the design process of a circuit, which is
%undesirable in an industry where the time for a device to move from conception
%to market is becoming critical, and ever shorter.
%
%%%\vspace{-2mm}
%\subsection{Towards high-level asynchronous concepts\label{sub:new-way}}
%In an attempt to streamline the design process, we aimed to find a way to
%create STGs which allows editing and reuse at various stages of the design.
%This way, if something needs to be corrected, this can be done to a small part,
%but we can reuse everything that works correctly. These parts can then be
%composed to produce a full STG which contains the corrections, with a minimum
%amount of time spent making the corrections.
%
%This led us to take the example of a simple buck converter, and compare what
%the STG shows, and what the description of operation of the system, in
%particular its signals, is. This allowed us to view interactions between
%certain signals which may not be obvious, but without which the STG would not
%be a correct representation of the design. For example,
%Figure~\ref{fig:stg-breakdown} shows one scenario of the simple buck converter
%with some points of interest highlighted.
%
%\begin{figure}[t]
%\begin{centering}
%\includegraphics[scale=0.225]{Images/stg-breakdown}
%\par
%\protect\caption{\label{fig:stg-breakdown}Deconstructing the STG of the ZC
%absent scenario.}
%\par\end{centering}
%%%\vspace{-4mm}
%\end{figure}
%
%Studying this STG shows that there are some high-level signal interactions that
%we can identify:
%\begin{itemize}
%\item High levels of $uv$ and $oc$ are mutually exclusive; indeed, $uv$ goes
%high (transition $uv^{+}$) only after $oc$ goes low (transition $oc^{-}$), and
%vice
%versa.
%\item High levels of $gp$ and $gn$ are also mutually exclusive.
%\item Signals $gp$ and $gp\_ack$ form a handshake, i.e. there is a cycle
%$gp^{+} \rightarrow gp\_ack^{+} \rightarrow gp^{-} \rightarrow gp\_ack^{-}$ etc.\item Signals $gn$ and $gn\_ack$ also form a handshake.
%\end{itemize}
%
%These interactions can also be identified in the informal buck description:
%$uv$ and $oc$ indicate opposite conditions in the circuit and will naturally be
%mutually exclusive, while $gp$ and $gn$ are used to switch PMOS and NMOS
%transistors respectively, and switching these transistors \noun{On} at the same
%time will cause a shortcircuit and is therefore prohibited. Signals $gp\_ack$
%and $gn\_ack$ are used to acknowledge the state of these transistors, and thus
%always follow $gp$ and $gn$, respectively, forming two separate handshakes.
%
%Knowing this information means that we can describe these protocols once, and
%include them in the design of any circuit involving these signals. Any other
%interactions between any of these signal will be subject to these protocols,
%which will prevent circuit breaking bugs in the testing phase. For example, an
%interaction involving $gp$ will ensure that it is never set high at
%the same time as $gn$, as otherwise the mutual exclusion will not hold.
%
%If one of these signals is removed, then the protocols that this affects can
%be removed, but the unaffected protocols can continue to be used, avoiding a
%major re-design which may happen when using the STG-based monolithic approach.
%
%With this idea in mind, we need to find a way to describe these protocols, as
%well as other signal interactions, in order to ensure that each different
%interaction can be edited without needing to change every single interaction.

%% + Here is the problem we are solving
%%
%%
%%
%%+ STGs are a conventional specification model, STGs tend to get very large and
%complex for real-life circuits (show simple-buck example STG)
%%
%%
%%
%%+ STGs mix many different concerns in one single graph -- show how one could
%split the specification into what we call concepts.
%%
%%%\vspace{-2mm}
%\section{Concepts \label{sec:Concepts}}
%
%In this section we formally introduce \emph{concepts} that we propose
%to employ for the specification of asynchronous circuits. Below we
%list (fairly standard) definitions and notational conventions that
%are used throughout the paper.
%
%We use $\mathbb{B}$ to denote the set of Boolean values $\{0,1\}$.
%Given two Boolean functions $f:X\rightarrow\mathbb{B}$ and
%$g:X\rightarrow\mathbb{B}$
%with the same domain $X$, we lift Boolean operators (disjunction~$\vee$,
%conjunction~$\wedge$, implication $\Rightarrow$, etc.) in the usual
%manner: $h=f\vee g$ means $h(x)=f(x)\vee g(x)$ for all $x\in X$,
%etc. Furthermore,~$\mathbf{0}$ and~$\mathbf{1}$ stand for constant
%Boolean functions that discard their input and return $0$
%and $1$, respectively.
%
%A \emph{monoid} is a set $M$ and a binary operation $\diamond : M\times
%M\rightarrow M$
%satisfying two axioms:
%\begin{itemize}
%\item Identity: $e\diamond a=a\diamond e=a$ for any $a\in M$, where $e\in M$
%is the \emph{identity element} of the monoid.
%\item Associativity: $a\diamond(b\diamond c)=(a\diamond b)\diamond c$ for
%all $a,b,c\in M$.
%\end{itemize}
%Monoid is the simplest mathematical structure that captures the notions
%of \emph{emptiness} and \emph{composition}. The concepts introduced
%in this section form \emph{commutative monoids}: they have identity
%elements corresponding to empty specifications, and can be composed
%to build complex concepts from simpler ones. The order of composition
%does not matter, i.e., the concepts commute: $a\diamond b=b\diamond a$
%for all $a,b\in M$.
%
%%%\vspace{-1mm}
%\subsection{Abstract concepts}
%
%We first describe \emph{abstract concepts} that we use as building
%blocks for developing \emph{domain specific concepts}, such as those
%related to asynchronous circuits (Section~\ref{sub:Concepts-for-asynchronous}).
%
%Abstract concepts are parameterised by finite sets of \emph{states}
%$S$ and \emph{events} $E$. The \emph{initial state concept} captures
%all possible (or \emph{permitted}) initial states of the system. In
%the most general form it is a function
%\[
%\mathsf{initial}:S\rightarrow\mathbb{B}
%\]
%that given a state $s\in S$ returns $1$ if $s$ is an initial state
%and $0$ otherwise. In practice this concept is often realised as
%a membership test of a set of initial states~$I\subseteq S$, i.e.
%$\mathsf{initial}(s)=s\in I$. However, we prefer the functional form
%because it is more abstract and permits other, often more efficient
%realisations. Note that~$\mathbf{0}$ and~$\mathbf{1}$ have natural
%interpretations as initial concepts: they correspond to systems with
%no initial states, and systems where any state can be initial, respectively.
%Initial state concepts form a commutative monoid with the identity
%element~$\mathbf{1}$ and the composition operation~$\wedge$. Intuitively,
%if a system comprises two subsystems then its initial state should
%satisfy constraints imposed by both subsystems, hence the conjunction
%operator.
%
%The \emph{event excitation concept} captures all states wherein a
%given event can occur (or is \emph{excited}). In the most general
%form it is a function
%\[
%\mathsf{excited}:E\times S\rightarrow\mathbb{B}
%\]
%that given an event $e\in E$ and a state $s\in S$ checks whether
%$e$ is excited in $s$. In practice this concept is often realised
%using \emph{interpreted graph models} such as Finite State Machines
%and Petri Nets~\cite{Cortadella}, STGs, Conditional Partial Order
%Graphs~\cite{CPOG1}, and others. A partial application of the excitation
%function is often useful: $\mathsf{excited}(e)$ captures all states where
%event $e$ is excited; for example, if $\mathsf{excited}(e)=\mathbf{0}$ then
%$e$ is never excited or \emph{dead}. Event excitation concepts also
%form a commutative monoid with~$e=\mathbf{1}$ and~$\diamond=\wedge$.
%This definition corresponds to the \emph{parallel composition} operation,
%a standard notion for many behavioural models~\cite{PCOMP}.
%
%Some states may be impossible or undesirable during the normal system
%operation. To express this we use the \emph{invariant concept}, which
%captures all \emph{correct} or \emph{permitted} states of the system.
%A typical use case for invariant concepts is to specify assertions
%or assumptions about the system state space, that may by verified
%via model checking and/or used for optimising the implementation.
%In the most general form an invariant concept is a function
%\[
%\mathsf{invariant}:S\rightarrow\mathbb{B}
%\]
%that given a state $s\in S$ returns $1$ if $s$ is permitted by
%the invariant and $0$ otherwise. Note that if for some state $s$
%the initial concept $\mathsf{initial}(s)$ holds but the invariant
%$\mathsf{invariant}(s)$ does not hold, then the specification is
%\emph{contradictory} and cannot be satisfied by any implementation.
%We therefore usually assume that
%$\mathsf{initial}(s)\Rightarrow\mathsf{invariant}(s)$
%holds for all $s\in S$. Similarly, invariant concepts form a commutative
%monoid with~$e=\mathbf{1}$ and~$\diamond=\wedge$. Intuitively,
%if a system comprises two subsystems then its states should be permitted
%in both of the subsystems.
%
%One can derive other useful concepts from the three concepts described
%above, for instance,
%\[
%\mathsf{silent}(e,s)=\overline{\mathsf{excited}(e,s)}
%\]
%captures all states $s\in S$ when a given event $e\in E$ cannot
%occur. Furthermore, one can define other useful concepts that cannot
%be derived from the above, e.g., the \emph{execution concept} capturing
%the effects that different events have on the system state. Due to
%space limitations we only consider the three concepts defined above
%and their derivatives.
%
%All the above concepts are monoids, hence their combinations are
%trivially monoids too. It is convenient to consider triples
%of concepts $(\mathsf{initial},\mathsf{excited},\mathsf{invariant})$
%with $(\mathbf{1},\mathbf{1},\mathbf{1})$ representing the \emph{empty
%specification}, and composition
%$(\mathsf{initial}_{1},\mathsf{excited}_{1},\mathsf{invariant}_{1})\diamond(\mathsf{initial}_{2},\mathsf{excited}_{2},\mathsf{invariant}_{2})$
%defined as
%$(\mathsf{initial}_{1}\diamond\mathsf{initial}_{2},\mathsf{excited}_{1}\diamond\mathsf{excited}_{2},\mathsf{invariant}_{1}\diamond\mathsf{invariant}_{2})$.
%Note that composition of two non-contradictory specifications is
%always non-contradictory, that is if both
%$\mathsf{initial}_{1}(s)\Rightarrow\mathsf{invariant}_{1}(s)$
%and $\mathsf{initial}_{2}(s)\Rightarrow\mathsf{invariant}_{2}(s)$
%hold for all states $s\in S$, then
%$\mathsf{initial}_{1}(s)\diamond\mathsf{initial}_{2}(s)\Rightarrow\mathsf{invariant}_{1}(s)\diamond\mathsf{invariant}_{2}(s)$
%holds too.

%%\vspace{-3mm}

\section{Asynchronous Concepts\label{sec:async-concepts}}

%%%\vspace{-2mm}

The abstract base of the concepts, on which these asynchronous specific circuits
is discussed in~\cite{2015_Beaumont_MEMOCODE}.

%We now introduce concepts which are specific for the domain of asynchronous
%circuits and express them using the abstract concepts defined above.

%\textbf{\label{signal-level}Signal-level concepts:} States and events of an
%asynchronous
%circuit are parameterised by a set of signals $A$. A state
%$s\in S$ is an assignment of Boolean values to signals, i.e. a function
%$s:A\rightarrow\mathbb{B}$, while an event $e\in E$ is a \emph{signal
%transition}, i.e. a pair $e:A\times\mathbb{B}$ comprising a signal
%$a\in A$ and the value of the signal \emph{after} the transition
%occurs. We call transitions $(a,0)$ and $(a,1)$ \emph{falling} and
%\emph{rising}, respectively, and denote them by $a^{-}$ and $a^{+}$
%for brevity.

%The following two predicates are very useful for constructing concepts:
%\[
%\begin{array}{ccc}
%\mathsf{before} & \!\!\!\!:\!\!\!\!\! & E\times S\rightarrow\mathbb{B}\\
%\mathsf{after} & \!\!\!\!:\!\!\!\!\! & E\times S\rightarrow\mathbb{B}
%\end{array}
%\]
%A state $s\in S$ is said to be \emph{before} a transition $(a,b)\in E$
%if $s(a)\neq b$, i.e. in state $s$ signal $a$ has a value which
%is different from the resulting value of the transition. Similarly,
%$s$ is \emph{after} $(a,b)$ if $s(a)=b$ (the transition has already
%occurred).
%
%We are now ready to define an excitation concept called
%\emph{consistency}~\cite{Cortadella}:
%\[
%\mathsf{consistency}=\mathsf{before}
%\]
%This concept captures the requirement that in a consistent asynchronous
%circuit a signal transition can only be excited in states that are
%before it.

\textbf{\label{signal-level}Signal-level concepts:} Asynchronous circuit specifications
are mainly composed of signal transitions, and interactions between these, to show
causal relationships. Signal transitions are denoted as $a^{+}$ and $a^{-}$, where $a$ is
any signal name, at least one character, and the $+$ or $-$ indicates which way the 
this signal transitions, $+$ denoting a low-to-high or 0 to 1 transition, and $-$ denoting
a high-to-low, 1 to 0 transition. 

Signal-level concepts are the base level of concepts, and are 
the type all other concepts are built on. Here we display the standard concepts
available at this level.

A key concept in asynchronous circuits is \emph{causality}:
one signal transition \emph{causes} another signal transition, a cause and an effect.
This is denoted in the form: 
\[
a^{+}\rightsquigarrow c^{+}
\]
This is read as $a^{+}$ causes $c^{+}$, meaning that for the $c^{+}$ transition to
occur, $a^{+}$ must have occurred previously. The $\rightsquigarrow$ operator is
used to show causal relationships between signals.
 
While this concept is called \emph{causality}, this doesn't necessarily imply
timings, such as any $\mathit{cause}$ transition immediately forcing the
 $\mathit{effect}$ transition it applies to. Causality can be used in order to
list all possible $\mathit{cause}$ transitions which need to occur in order
 for an $\mathit{effect}$ transition.

One can compose any concepts using the $\diamond$ (diamond) operator, and this applies
to concepts of any level, whether predefined or user-defined. For example, 
two causality concepts can be composed.
\[
a^{+}\rightsquigarrow c^{+}\ \diamond\ b^{+}\rightsquigarrow c^{+}
\]
In words, $a^{+}$ \emph{and} $b^{+}$ must occur before $c^{+}$ can occur. 
This corresponds to so-called AND-causality in the fact that several cause transitions \emph{must all}
have occurred before an event can occur. AND-causality is commonly used
to imply behaviours in circuits, for specific requirements of effect transitions.  

The above notation can cause long-winded specifications when lots of AND-causality is involved. 
To solve this we provise a listing option. The following will acheive the same results:

%%\vspace{-3mm}

\[
[a^{+}, b^{+}]\sim\hspace{-1.5mm}\&\hspace{-1.5mm}\sim\hspace{-1.5mm}>c^{+}
\]
This form of concept can be composed as usual with any other concepts.

A less common, but still useful form of causality is OR-causality. This is where an effect transition
can have several possible cause transitions. Only one cause transition is required to occur to allow
the effect transition to occur. 

%Specifying OR-causality is slightly more tricky:
%\[
%\mathsf{orCausality}(x^{+},y^{+},z^{+})(e)=\begin{cases}
%\mathbf{1} & \mathit{if}\, z^{+}\neq\mathit{e}\\
%\mathsf{after}(x^{+})\vee\mathsf{after}(y^{+}) & \mathit{otherwise}
%\end{cases}
%\]
%Event $z+$ is thus excited after at least one cause has occurred. OR-causality is less-common,
%but is useful in some standard gates, as we will discuss in Section~\ref{sec:examples}.

%As with AND-causality, we have implemented a list notation for OR-causality. Instead of listing
%all the required cause transitions, one can list all the possible cause transitions per effect transition.

With OR-causality, the notation used lists all possible causes for the stated effect:

%%\vspace{-3mm}

\[
[x^{+}, y^{+}]\sim\hspace{-1.5mm}|\hspace{-1.5mm}\sim\hspace{-1.5mm}>z^{+}
\]

This is, \emph{either} $x^{+}$ \emph{or} $y^{+}$ must occur in order for 
$z^{+}$ to occur.

The interactions when an effect transition is included in both AND- and OR-causality are interesting, and
an example of when this occurs can be found in Section~\ref{sec:algorithm}, along with a description
of the implemented algorithm, which discusses the issues OR-causality poses with translation.

\textbf{Gate-level concepts:} Using the causality concept we can express
the behaviour of gates in asynchronous circuits. For example, a \emph{buffer}
is a gate with one input signal and one output signal ,
whose output transitions causally depend on the input ones:
\[
\mathsf{buffer}(a, b)=a^{+}\rightsquigarrow b^{+}\ \diamond\
a^{-}\rightsquigarrow b^{-}
\]

\noindent An \emph{inverter} has a similar conceptual specification, but the
output transition is inverted:
\[
\mathsf{inverter}(a, b)=a^{+}\rightsquigarrow b^{-}\ \diamond\
a^{-}\rightsquigarrow b^{+}
\]
% TODO: Maybe bring this back.
% An \emph{SR-Latch} has two input signals, $s$ and $r$ each of which cause
%differing transitions with the output, $q$:
% \[
% \mathsf{SRLatch}\,s \,r \,q=s^{+}\!\rightsquigarrow\! q^{+}\ \diamond\
%r^{+}\!\rightsquigarrow\! q^{-}\ \diamond\ s^{-}\!\rightsquigarrow\! q^{-}\
%\diamond\ r^{-}\!\rightsquigarrow\! q^{+}
% \]
% This can be described as, the\emph{set} signal, $s$ when active, or high, will
%cause the gate to latch a high state, outputting this with signal $q$ being
%high. Conversely, the \emph{reset} signal, $r$, when active, or high, will cause
%the gate to latch a low state, and the output $q$ will be low in this case.
% Another way of specifying this gate using concepts is to use the buffer and
%inverter concepts defined above, as the signals $s$ and $q$ have an interaction
%the same as a buffer, and signals $r$ and $q$ interaction is the same as an
%inverter.
% \[
% \mathsf{SRLatch}\,s \,r \,q=\mathsf{buffer}\,s \,q \ \diamond\
%\mathsf{inverter}\,r \,q
% \]

%An \emph{AND gate} has two inputs $a$ and $b$ and one output~$c$, which
%synchronises rising transitions via AND-causality and falling transitions
%via OR-causality:
%\[
%\mathsf{and}(a, b, c)=a^{+}\!\rightsquigarrow\!c^{+} \diamond\
%b^{+}\!\rightsquigarrow\! c^{+} \diamond\
%\mathsf{orCausality}(a^{-},b^{-},c^{-})
%\]

\noindent A \emph{C-element} is a gate with two inputs, in this example $a$ and $b$ and one
output~$c$, which synchronises both rising and falling input transitions
via AND-causality:
\[
\mathsf{cElement}(a, b, c)=a^{+}\!\rightsquigarrow\! c^{+}\ \diamond\
b^{+}\!\rightsquigarrow\! c^{+}\ \diamond\ a^{-}\!\rightsquigarrow\! c^{-}\
\diamond\ b^{-}\!\rightsquigarrow\! c^{-}
\]
% In words, the rising output transition $c^{+}$ causally depends on
% both $a^{+}$ and $b^{+}$, and the falling output transition $c^{-}$
% causally depends on both $a^{-}$ and $b^{-}$.
An alternative way to express the same concept is to reuse the buffer concept:
\[
\mathsf{cElement}(a, b, c)=\mathsf{buffer}(a, c) \diamond \mathsf{buffer}(b, c)
\]
A C-element combines the constraints imposed on the output
transitions by two `virtual' buffers. An expanded example of a C-element can be
found in~\cite{2015_Beaumont_MEMOCODE}.

Behaviour of other gates can be similarly defined using concepts. We will dicuss
this in Section~\ref{sec:examples}.
%see our open-source implementation~\cite{2016_concepts_github}.

\textbf{Protocol-level concepts:} In addition to gate-level concepts
described above it is often important to specify \emph{protocols}
of interaction between multiple gates, components or signals. 
%as discussed in the motivating example Section~\ref{sub:new-way}.

Here we demonstrate how one can use concepts to specify asynchronous handshakes
and mutual exclusion mechanisms.

Given two signals $a$ and $b$, a \emph{handshake} between them is
the following composition of causality concepts:
\[
\mathsf{handshake}(a, b)=a^{+}\!\rightsquigarrow\! b^{+}\ \diamond\
b^{+}\!\rightsquigarrow\! a^{-}\ \diamond\ a^{-}\!\rightsquigarrow\! b^{-}\
\diamond\ b^{-}\ \rightsquigarrow\! a^{+}
\]
Intuitively, we have a two-way asynchronous communication channel,
where one party sends transitions $a^{+}$ and $a^{-}$ and the other
party responds by corresponding $b^{+}$ and $b^{-}$ transitions.
Note that the four causality concepts match those found
in the buffer and inverter concepts, which leads to an alternative
way to express a handshake between~$a$ and~$b$:
\[
\mathsf{handshake}(a, b)=\mathsf{buffer}(a, b) \diamond\mathsf{inverter}(b, a)
\]
This conceptual understanding of a handshake as being composed
from a buffer and an inverter is often used by circuit designers as
a convenient way of reasoning.

%In order to specify the initial state of a handshake between signals~$a$
%and~$b$, we use the $\mathsf{initialise}$ concept:
%\[
%\mathsf{initialise}(\mathit{signal},\mathit{value})=\mathsf{after}(signal,
%value)
%\]
%
%\noindent For example, $\mathsf{initialise}(a, 0)$ sets the state of the signal
%$a$ to $0$. We can compose an initial state concept with the handshake concept
%into a combined $\mathsf{handshake00}(a, b)$ concept as
%\[
%\mathsf{handshake}(a, b) \diamond \mathsf{initialise}(a, 0) \diamond
%\mathsf{initialise}(b, 0)
%\]
%The resulting concept corresponds to a handshake between signals~$a$
%and~$b$ that are both initially $0$.

The last standard concept is \emph{mutual
exclusion} between two signals~$a$ and~$b$:
\[
\mathsf{me}(a, b) = a^{-}\rightsquigarrow b^{+}\ \diamond\ b^{-}\rightsquigarrow
a^{+}
\]
The concept states that, in terms of causality, rising transitions 
$a^{+}$ and $b^{+}$ can only occur after
the opposite falling signal transitions. Therefore, even if all other cause-transitions for
either $a^{+}$ or $b^{+}$ have occurred, while the one signal is high, this blocks 
the other from transitioning high. This guarantees that $a$ and
$b$ are never set to $1$ at the same time, i.e. they are mutually
exclusive.

We can now specify a \emph{mutual exclusion
element}~\cite{2008_kinniment_synchronisation}
that receives asynchronous requests $r_{1}$ and $r_{2}$ to a shared
resource and grants access to it by corresponding mutually exclusive
signals $g_{1}$ and $g_{2}$:

%%\vspace{-3mm}
{\small
\[
\mathsf{meElement}(r_{1}, r_{2}, g_{1}, g_{2})\!=\!\mathsf{buffer}(r_{1}, g_{1})
\diamond \mathsf{buffer}(r_{2}, g_{2}) \diamond \mathsf{me}(g_{1}, g_{2})
\]}

%%\vspace{-8mm}

\section{Concepts for translation\label{sec:trans-concepts}}

The concepts we have discussed so far are aimed at specifying the behaviour of signals in a circuit.
When translating these to STGs however, these behaviours do not necessarily result in a correct
specification, meaning they will not be verifiable by standard tools, and therefore not useful in 
further operations, such as synthesis.

This is due to various parts of an STG that we have not yet discussed, which are important
for specification, namely \emph{interface} and \emph{initial states}.

%%\vspace{-5mm}

\subsection{Interface concepts \label{sub:interface}} 

An important part of a specification is how these signals interact with the outside world, which could
be another scenario or another circuit, for example. These signals can be inputs from the outside world,
outputs or an internal signal, which is used only within this scenario. 

To specify the type of a signal (\emph{input},
\emph{output} or \emph{internal}) we introduce the \textsf{interface} concept:
\[
\mathsf{interface} : A \rightarrow \{\mathsf{Input}, \mathsf{Output},
\mathsf{Internal}\}
\]
Signal types are composed according to the following rules:
\[
\begin{array}{|l||l|l|l|}
\hline
\multicolumn{1}{|c||}{\diamond} & \mathsf{Input} & \mathsf{Output} &
\mathsf{Internal} \\ \hline \hline
\mathsf{Input} & \mathsf{Input} & \mathsf{Output} & \mathsf{Internal} \\ \hline
\mathsf{Output} & \mathsf{Output} & \mathsf{Output} & \mathsf{Internal} \\
\hline
\mathsf{Internal}& \mathsf{Internal} & \mathsf{Internal} & \mathsf{Internal} \\
\hline
\end{array}
\]
The intuition is as follows:
\begin{itemize}
    \item If a signal is an input in one component of the system, but is an
    output in another components, then in the composition it will be an output.
    \item An internal signal is similar to an output signal in the sense
that it is driven by the circuit (not the environment), but it is hidden, i.e.not accessible via the circuit interface. Once a signal is hidden and declared    internal it cannot be revealed.
\end{itemize}

\noindent Specifying signal types is important when designing asynchronous
circuits, as it helps to quickly identify errors (e.g. an input transition is
caused by a hidden internal transition), and reuse existing tools for circuit
simulation, verification and synthesis. Signal type information is also used
in the algorithm for automated translation of concepts to
STGs (Section~\ref{sec:algorithm}).

Concepts \textsf{inputs}, \textsf{outputs}, \textsf{internals} are defined for
specifying types of sets of signals for convenience, and to be included inline with other
concepts. For example, to specify
that signals $a$ and $b$ are inputs, $c$ is an output, and $t$ is internal, it
is possible to write:
\[
\mathsf{inputs}(\{a, b\}) \diamond \mathsf{outputs}(\{c\}) \diamond
\mathsf{internals}(\{t\}).
\]

%%\vspace{-5mm}

\subsection{Initial state concepts \label{sub:initState}}

Specifying the initial state is important, as it determines what the first transitions
of a scenario will be. Without these, no transition can occur.

Each signal must have it's initial state declared before translation can occur. 
In order to specify the initial state of a handshake between signals~$a$
and~$b$, we use the $\mathsf{initialise}$ concept:
\[
\mathsf{initialise}(\mathit{signal},\mathit{value})=\mathsf{after}(signal,
value)
\]

\noindent The possible initial states are \emph{high} or \emph{low}, referred to as \emph{0} 
or \emph{1} respectively:

\[
\mathsf{initialise}(a,0) \diamond \mathsf{initialise}(x, 1)
\]

\noindent A signal can only be declared as initially high or low. If the initial state of a signal is 
not defined, and error will occur, and the translation will not continue. Conversely, 
if the event a signal has it's initial state declared as both high and low,
and is thus inconsistent, in a specification then the translation will also fail.

For the ease of use, and to speed up the process, initial states can also be declared
in lists by on state:

\[
\mathsf{initialise0} [a, b, c] \diamond \mathsf{initialise1} [x, y]
\]


\noindent As an example, we can include this in the specification of a handshake, to 
create a handshake with built-in initial state.
$\mathsf{initialise}(a, 0)$ sets the state of the signal
$a$ to $0$. We can compose an initial state concept with the handshake concept
into a combined $\mathsf{handshake00}(a, b)$ concept as
\[
\mathsf{handshake00} = \mathsf{handshake}(a, b) \diamond \mathsf{initialise}(a, 0) \diamond
\mathsf{initialise}(b, 0)
\]
The resulting concept corresponds to a handshake between signals~$a$
and~$b$ that are both initially $0$.

%%\vspace{-3mm}

\section{Concept examples \label{sec:examples}}

In our previous paper, \cite{2015_Beaumont_MEMOCODE}, we have 
used a C-element as a small example of how we can specify a standard gate with concepts,
and how there are several ways of describing these with concepts. 

In this section, we will discuss the concept specification of some different gates,
a Set-Reset latch which uses AND-causality, and an OR-gate and an AND-gate, both of 
which use both AND- and OR-causality, and this proves to be more difficult to translate,
which we will use an example in Section~\label{translation-algorithm}.

%%\vspace{-3mm}

\subsection{Set-reset latch \label{sub:srlatch}}

A set-reset latch (S-R latch) is a particularly simple logic gate, used to store either a zero or one,
depending on the inputs. 

%%\vspace{-5mm}

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.51]{Images/sr-latch-circuit}
\par\end{centering}
%%\vspace{-1mm}
\protect\caption{\label{fig:sr-latch-circuit} The symbol of an SR-latch}
%%\vspace{-3mm}
\end{figure}

\noindent There are two input signals for this gate, $s$ and $r$, and a single output, $q$: 

\begin{itemize}
  \item $s$: \emph{set} - When this signal is high, it sets the output, meaning it sets it high.
  \item $r$: \emph{reset} - When this signal is high, it resets the output, meaning it sets it low.
  \item $q$: \emph{latched bit} - This stores the desired value, set depending on the values of the input signals.
\end{itemize}

\noindent From this information, we can start to specify the gate with concepts.

First of all, we know the types of these signals, so let us sepcify the interface concept.

%%\vspace{-2mm}

\[
\begin{array}{lcl}
\mathsf{interface}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{inputs}[s, r]~\diamond~\mathsf{outputs}[q]
\end{array}
\]

\noindent Now we move onto the interaction between signals. First of all, to set the output high.
When $s$ is high, this causes $q$ to go high. However, only after $s$ goes low can $q$ go low.
In concepts this is: 

%%\vspace{-3mm}

\[
\begin{array}{lcl}
\mathsf{set}&\hspace{-2mm}=&\hspace{-2mm}s^{+} \rightsquigarrow q^{+} \diamond\, s^{-} \rightsquigarrow q^{-}
\end{array}
\]

\noindent The interaction between the reset signal and the output will be opposite to this; $r$ going high causes $q$ 
to go low. Only after $r$ goes low can $q$ go low. The concept for this is:

%%\vspace{-2mm}
\[
\begin{array}{lcl}
\mathsf{reset}&\hspace{-2mm}=&\hspace{-2mm}r^{+} \rightsquigarrow q^{-} \diamond\, r^{-} \rightsquigarrow q^{+}
\end{array}
\]

\noindent The next concept to specify is the initial state. The description given mentions nothing
to help with the initial state, but let's assume we would like the output to initially be 0. 
To then allow the S-R latch to react only to the inputs, we can set the initial states of the 
inputs to 0 too. This will mean that $s$ is not trying to take the output high, and $q$ is not
blocking the output from going high. 

\[
\begin{array}{lcl}
\mathsf{initialState}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{initialise0} [s, r, q]
\end{array}
\]

\noindent Finally, we can compose all of these concepts, in order to translate them to an STG. This concept will be:

%%\vspace{-3mm}

\[
\begin{array}{lcl}
\mathsf{SRLatch}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{set} \diamond\, \mathsf{reset} \diamond\, \mathsf{interface} 
\diamond\, \mathsf{initialState}.
\end{array}
\]

\noindent It is possible reuse some previously defined concepts for the specification of an SRLatch,
which may be preferred by users, as these describe their behaviour in terms of gates.  

The $set$ concept features the same signal-level concepts as a buffer, and thus can be redefined
as a buffer of $s$ and $q$. Similarly, the $reset$ concept can be replaced by an inverter between
$r$ and $q$. Two gates cannot be connected in this way in an actual circuit, however
it defines their behaviours in a different way, which may be understood better in some cases.

Since this now reduces the number of concepts, and thus the length of the specification, we
can define an SR-latch as follows:

%%\vspace{-3mm}

 \[
\begin{array}{lcl}
\mathsf{SRLatch}&\hspace{-2mm}=\mathsf{buffer}(s, q) \diamond\, \mathsf{inverter}(r, q) \diamond\, \mathsf{inputs}[s, r]\\ 
&\diamond\, \mathsf{outputs}[q] \diamond\, \mathsf{initialise0} [s, r, q]
\end{array}
\]

\noindent It's isn't necessary to split a scenario specification up into several concepts. 
Depending on the size of the specification, it may be simpler and quicker to 
produce a single concept like this.

Either of these concept specifications can be translated to produce an STG. 
The translated STG can be found in Figure~\ref{fig:sr-latch-stg}.

%%\vspace{-3mm}

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.25]{Images/sr-latch-stg}
\par\end{centering}
%%\vspace{-1mm}
\protect\caption{\label{fig:sr-latch-stg} An SR-latch STG}
%%\vspace{-5mm}
\end{figure}

%%\vspace{-5mm}
\subsection{OR-gate \label{sub:or-gate}}

The S-R latch features only AND-causality, and as we displayed 
in~\cite{2015_Beaumont_MEMOCODE}, with the examples of a C-element 
and a Buck controller, which only feature AND-causality, these can be translated
to an STG. 

OR-causality is quite different however, and causes some significant differences 
in a resulting STG, as we will see with the example of an OR-gate. 

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.55]{Images/or-gate-circuit}
\par\end{centering}

\protect\caption{\label{fig:or-gate-circuit} The circuit diagram of an OR-gate}
%%\vspace{-3mm}
\end{figure}

Let's start by specifying the OR-gate. There are three signals, which for this 
example we will call $a$ and $b$ which are inputs, and $c$ which is the only output:

\begin{itemize}
  \item $a$ - When either this signal or $b$ is high, the output should be set high.
  \item $b$ - When either this signal or $a$ is high, the output should be set high.
  \item $c$ - This output signal is high when at least one of the inputs is high, but low when
		\emph{both} input signals are low.
\end{itemize}

As with the S-R latch, we can start by specifying the interface: 

%%\vspace{-4mm}

\[
\begin{array}{lcl}
\mathsf{interface}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{inputs}[a, b]~\diamond~\mathsf{outputs}[c]
\end{array}
\]

\noindent Again, there is no information on the initial state. By the description, we can
assume that setting all signals to be initially low will mean that the output
will not be able to go high. Thus we can define the initial state as:

%%\vspace{-2mm}

\[
\begin{array}{lcl}
\mathsf{initialState}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{initialise0} [a, b, c]
\end{array}
\]

\noindent For the interaction between signals, let's start by specifying the concept which 
describes what causes the output to go low:

%%\vspace{-4mm}
\[
\begin{array}{lcl}
\mathsf{outputFall}&\hspace{-2mm}=&\hspace{-2mm}a^{-} \rightsquigarrow c^{-} \diamond\, b^{-} \rightsquigarrow c^{-}
\end{array}
\]

\noindent In words, this means that both $a^{-}$ and $b^{-}$ must have occured before $c^{-}$ can occur. 
This is AND-causality as we have used in previous examples. 

For a slightly more compact specification, we can rewrite this concept as:
%%\vspace{-3mm}
\[
\begin{array}{lcl}
\mathsf{outputFall}&\hspace{-2mm}=&\hspace{-2mm}[a^{-}, b^{-}] \sim\hspace{-1.5mm}\&\hspace{-1.5mm}\sim\hspace{-1.5mm}> c^{-} 
\end{array}
\]

\noindent The concept specifying the output going high is slightly different, because only one of
$a$ and $b$ must be high in order for $c$ to go high. This is OR-causality and specifying 
this in concepts is not too difficult: 
                                                                                                                                                                                                                                                                                                                                                        
%%\vspace{-3mm}
\[
\begin{array}{lcl}
\mathsf{outputRise}&\hspace{-2mm}=&\hspace{-2mm}[a^{+}, b^{+}] \sim\hspace{-1.5mm}|\hspace{-1.5mm}\sim\hspace{-1.5mm}> c^{+} 
\end{array}
\]

\noindent This lists the possible cause transitions of $c^{+}$, namely $a^{+}$ and $b^{+}$. 

This completes the specification, so let's compose these conepts for the full OR-gate
specification:

%%\vspace{-3mm}
\[
\begin{array}{lcl}
\mathsf{orGate}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{outputFall} \diamond\, \mathsf{outputRise} \diamond\, \mathsf{interface} 
\diamond\, \mathsf{initialState}
\end{array}
\]

\noindent With the OR-gate it is not possible to use pre-defined concepts, but we do not need to
specify the individual concepts for a similarly sized specification:

%%\vspace{-3mm}
\[
\begin{array}{lcl}
\mathsf{orGate}\,a \,b \,c&\hspace{-2mm}=[a^{-}, b^{-}] \sim\hspace{-1.5mm}\&\hspace{-1.5mm}\sim\hspace{-1.5mm}> c^{-} \diamond\, [a^{+}, b^{+}] \sim\hspace{-1.5mm}|\hspace{-1.5mm}\sim\hspace{-1.5mm}> c^{+} \\
&\diamond\, \mathsf{inputs}[a, b] \diamond\, \mathsf{outputs}[c] \diamond\, \mathsf{initialise0} [a, b, c]
\end{array}
\]

\noindent The difficulty with OR-causality comes with translation. The translated STG for an OR-gate
can be found in Figure~\ref{fig:or-gate-stg}, and features one major difference.
%%\vspace{-3mm}
\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.25]{Images/or-gate-stg}
\par\end{centering}
%%\vspace{-1mm}
\protect\caption{\label{fig:or-gate-stg} An OR-gate STG}
%%\vspace{-3mm}
\end{figure}

This STG features 2 different $c^{+}$ transitions, due to the OR-causality. 
This is for each possible cause, and it is visible that one is connected via a 
read-arc to the $a1$ place and the other is connected via a read-arc to 
the $b1$ place. This allows $c^{+}$ to transition if either $a^{+}$, 
$b^{+}$ or both of these has occured.

Note that there is still only one $c^{-}$ transition, as this requires both
$a^{-}$ and $b{-}$ to have transitioned.

%%\vspace{-3mm}

\subsection{AND-gate}

An AND-gate, unlike what the name suggests also features OR-causality. 
For the output to go high, the input signals are in an AND-causality relationship
with the output, however, only one of the inputs needs to transition low for the 
output to go low. 

%%\vspace{-3mm}

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.55]{Images/and-gate-circuit}
\par\end{centering}

\protect\caption{\label{fig:or-gate-circuit} The circuit diagram of an AND-gate}
%%\vspace{-3mm}
\end{figure}

This example also features 3 signals, $a$ and $b$ which are inputs, and $c$
which is an output:

\begin{itemize}
  \item $a$ - When this signal and $b$ are high, the output should be set high.
  \item $b$ - When this signal and $a$ are high, the output should be set high.
  \item $c$ - This output signal is high when all of the inputs are high, but low when
		\emph{at least} one of the input signals are low.
\end{itemize}

\noindent Again, we can start with the interface: 

%%\vspace{-1mm}
\[
\begin{array}{lcl}
\mathsf{interface}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{inputs}[a, b]~\diamond~\mathsf{outputs}[c]
\end{array}
\]

\noindent With the initial state, we can again assume that setting all signals low initially will mean 
that no signals are causing any other signal transitions:

%%\vspace{-2mm}
\[
\begin{array}{lcl}
\mathsf{initialState}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{initialise0} [a, b, c]
\end{array}
\]

\noindent Now for signal interactions. For the output to go high, both input signals must
transition high. This concept is: 

%%\vspace{-1mm}
\[
\begin{array}{lcl}
\mathsf{outputRise}&\hspace{-2mm}=&\hspace{-2mm}a^{+} \rightsquigarrow c^{+} \diamond\, b^{+} \rightsquigarrow c^{+}
\end{array}
\]

\noindent This concept can also be written as:

\[
\begin{array}{lcl}
\mathsf{outputRise}&\hspace{-2mm}=&\hspace{-2mm}[a^{+}, b^{+}] \sim\hspace{-1.5mm}\&\hspace{-1.5mm}\sim\hspace{-1.5mm}> c^{+} 
\end{array}
\]

\noindent OR-causality is necessary for an AND-gate when specifying the output falling. Either $a^{-}$,
$b^{-}$ or both must occur before $c^{-}$ can occur. In concepts, we list the possible
causes for the effect:

%%\vspace{-3mm}
\[
\begin{array}{lcl}
\mathsf{outputFall}&\hspace{-2mm}=&\hspace{-2mm}[a^{-}, b^{-}] \sim\hspace{-1.5mm}|\hspace{-1.5mm}\sim\hspace{-1.5mm}> c^{-} 
\end{array}
\]

\noindent We can now compose these for an AND-gate specification. As with the previous examples
this can be in two forms.

%%\vspace{-3mm}
\[
\begin{array}{lcl}
\mathsf{andGate}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{outputRise} \diamond\, \mathsf{outputFall} \diamond\, \mathsf{interface} 
\diamond\, \mathsf{initialState}
\end{array}
\]

\noindent A compact version can be formed in this way:

%%\vspace{-2mm}
 \[
\begin{array}{lcl}
\mathsf{andGate}&\hspace{-2mm}=[a^{+}, b^{+}] \sim\hspace{-1.5mm}\&\hspace{-1.5mm}\sim\hspace{-1.5mm}> c^{-} \diamond\, [a^{-}, b^{-}] \sim\hspace{-1.5mm}|\hspace{-1.5mm}\sim\hspace{-1.5mm}> c^{-} \\
&\diamond\, \mathsf{inputs}[a, b] \diamond\, \mathsf{outputs}[c] \diamond\, \mathsf{initialise0} [a, b, c]
\end{array}
\]
\\
\noindent This can now be translated, and the resulting STG can be viewed in Figure~\ref{fig:and-gate-stg}

%%\vspace{-3mm}

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.25]{Images/and-gate-stg}
\par\end{centering}
%%\vspace{-1mm}
\protect\caption{\label{fig:and-gate-stg} An AND-gate STG}
%%\vspace{-2mm}
\end{figure}

This STG is similar to the OR-gate STG~(Figure~\ref{fig:or-gate-stg}), however
in this image, there are two $c^{-}$ transitions, one of which connects to $a0$
via a read-arc, the other of which connects to $b0$. This way, either $a^{+}$ 
, $b^{+}$, or both of these will allow $c^{+}$ to occur. However, both $a$ and
$b$ transitioning high is necessary for $c$ to transition high. 

We have shown the difference that OR-casuality can make to an STG in this
section, but not how this affects the translation. In Section~\ref{sec:algorithm} we 
will discuss the implemented translation algorithm. 

%\section{Circuit specification with concepts \label{sec:Circuit-specification-with}}
%
%%%\vspace{-2mm}
%
%Here we present a method for deriving a circuit specification
%from a set of concepts that describe its different aspects. We focus
%on specification of \emph{speed-independent}~(SI) circuits, which
%is an important class of asynchronous circuits~\cite{Muller_1959_ts}
%that work correctly regardless of the gate delays, while the wires
%are assumed to have negligible delays. Alternatively, one can regard
%wire forks as isochronic and add wire delays to the corresponding
%gate delays~(\emph{Quasi-Delay Insensitive}~(QDI) circuit
%class~\cite{Martin_1986_dc}).
%A convenient formalism for specification of SI circuits is
%STGs~\cite{Chu_1987_phd}\cite{Rosenblum_1985_tpn},
%which is a special kind of Petri nets~\cite{Petri_1962_phd} whose
%transitions are associated with signal events.
%
%%\vspace{-1mm}
%\subsection{Petri nets and STGs}
%
%Formally, a Petri net is defined as a tuple~$PN=\left\langle P,\, T,\, F,\,
%M_{0}\right\rangle $
%comprising finite disjoint sets of \emph{places~}$P$ and \emph{transitions~}$T$,\emph{arcs} denoting the flow relation~$F\subseteq\left(P\times
%T\right)\cup\left(T\times P\right)$
%and \emph{initial~marking~}$M_{0}$. There is an arc between~$x\in P\cup T$
%and~$y\in P\cup T$ iff $\left(x,y\right)\in F$. The \emph{preset}
%of a node $x\in P\cup T$ is defined as $\bullet x=\left\{
%y\mid\left(y,x\right)\in F\right\} $,
%and the \emph{postset} as $x\bullet=\left\{ y\mid\left(x,y\right)\in F\right\}
%$.
%The dynamic behaviour of a Petri net is defined as a \emph{token~game},
%changing marking according to the enabling and firing rules. A \emph{marking}
%is a mapping~$M:\, P\rightarrow\mathbb{N}$ denoting the number of
%\emph{tokens} in each place~($\mathbb{N}=\left\{ 0,1\right\} $ for
%\emph{1-safe} Petri nets). A transition $t$ is \emph{enabled} iff
%$\forall p,p\in\bullet t\Rightarrow M(p)>0$. The evolution of a Petri
%net is possible by \emph{firing} the enabled transitions. \emph{Firing}
%of a transition~$t$ results in a new marking $M'$ such that
%\[
%\forall p~M'(p)=\left\{ \begin{array}{ll}
%M(p)-1 & \textit{if}\, p\in\bullet t\setminus t\bullet,\\
%M(p)+1 & \textit{if}\, p\in t\bullet\setminus\bullet t,\\
%M(p)\,\,\,\,\, & \textit{otherwise}.
%\end{array}\right.
%\]
%
%An STG is a 1-safe Petri net whose transitions are labelled by signal
%events, i.e. $STG=\left\langle P,\, T,\, F,\, M_{0},\,\lambda,\, Z,\,
%v_{0}\right\rangle $,
%where $\lambda$ is a \emph{labelling~function}, $Z$ is a set of
%\emph{signals} and $v_{0}\in\left\{ 0,\,1\right\} ^{\left|Z\right|}$
%is a \emph{vector~of}~\emph{initial~signal~values}. The labelling
%function $\lambda:T\rightarrow Z^{\pm}$ maps transitions into
%\emph{signal~events}
%$Z^{\pm}=Z\times\left\{+,-\right\}$. The signal events labelled $z^{+}$
%and $z^{-}$ denote the transitions of signals $z\in Z$ from 0~to~1~(rising
%edge), or from 1~to~0~(falling edge), respectively. The labelling
%function does not have to be 1-to-1, i.e. transitions with the same
%label may occur several times in the net. To distinguish transitions
%with the same label and refer to them from the text an index $i\in\mathbb{N}$
%is attached to their labels as follows: $\lambda\left(t\right)/i$,
%where $i$ differs for different transitions with the same label.
%STGs inherit the operational semantics of their underlying PNs, including
%the notions of transition enabling and firing.
%
%Graphically, the places are represented as circles, transitions as
%text labels, arcs are shown by arrows, and tokens are depicted by dots.
%For simplicity, the places with one incoming
%and one outgoing arc are often hidden, allowing arcs~(with implicit
%places) between transitions.
%
%\begin{figure}[t]
%\begin{centering}
%\includegraphics[scale=0.51]{Images/C-element-with-environment}
%\par\end{centering}
%%\vspace{-1mm}
%\protect\caption{\label{fig:cElement-concepts}Example system specified using
%concepts.}
%%\vspace{-5mm}
%\end{figure}
%
%%\vspace{-1mm}
%\subsection{Composition of concepts\label{sub:Comp-of-concepts}}
%
%A single concept can be used to describe an initial state, invariant
%states, a single event or a combination of these, yet describing some
%protocols using this method can become long winded, as these can involve
%multiple events. We make use of the monoid composition of concepts
%to describe complex systems incrementally. Importantly we can mix
%several levels of system description and refer to signal, gate and
%protocol level concepts in one specification, depending on which level
%is more convenient in a particular situation.
%
%Consider an example of a C-element, which has signals $a$ and $b$ as inputs,
%and signal $c$ is the output. The output of this C-element is connected to
%each of the inputs via an inverter. This is a simple example of a complete
%system, of a C-element with an environment, see
%Figure~\ref{fig:cElement-concepts}.
%The example can be described by the following script:
%
%%\vspace{-3mm}
%\[
%\begin{array}{lcl}
%\mathsf{circuit}(a,b,c)&\hspace{-2mm}=&\hspace{-2mm}\mathsf{interface}~\diamond~\mathsf{outputRise}~\diamond~\mathsf{inputFall}\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{outputFall}~\diamond~\mathsf{inputRise}~\diamond~\mathsf{initialState}\\
%\mathsf{where}&~&\\
%\,\,\,\,\,\,\mathsf{interface}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{inputs}(\{a,b\})\diamond\mathsf{outputs}(\{c\})\\
%\,\,\,\,\,\,\mathsf{outputRise}&\hspace{-2mm}=&\hspace{-2mm}\,a^{+}\rightsquigarrow
%c^{+}\,\diamond\, b^{+}\rightsquigarrow c^{+}\\
%\,\,\,\,\,\,\mathsf{inputFall}&\hspace{-2mm}=&\hspace{-2mm}c ^ {+}
%\rightsquigarrow a^{-} \diamond\, c ^ {+} \rightsquigarrow b^{-}\\
%\,\,\,\,\,\,\mathsf{outputFall}&\hspace{-2mm}=&\hspace{-2mm}a^{-}
%\rightsquigarrow c^{-} \,\diamond\, b^{-} \rightsquigarrow c^{-}\\
%\,\,\,\,\,\,\mathsf{inputRise}&\hspace{-2mm}=&\hspace{-2mm}c^{-}
%\rightsquigarrow a^{+} \,\diamond\, c^{-} \rightsquigarrow b^{+}\\
%\,\,\,\,\,\,\mathsf{initialState}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{initialise}(a,0)
%\diamond \mathsf{initialise}(b,0) \diamond \mathsf{initialise}(c,0)\\
%\end{array}
%\]
%
%The first concepts in this list is the \textsf{circuit} concept, defined as a
%composition of the following five listed after the \textsf{where} keyword.
%They describe certain aspects of the system: the first four are named
%according to what they represent, for example, \textsf{outputRise} describes
%the events which cause the output to rise, and the final concept defines
%the initial states.
%
%%The sixth concept composes all of the first
%%5 concepts, and can be translated to the STG shown in Figure~\ref{fig:cElement
%%STG composition}.
%%The first four are named according to what they represent, for example,
%%\textsf{\textit{\emph{outputRise}}}\textit{ }describes the events
%%which cause the output to rise\textit{.} The fifth concept is the
%%initial state concept. This is necessary for the algorithm to produce
%%a scenario STG, as the STG produced will not be usable without knowing
%%the states the signals will be in when the scenario is entered. The
%%algorithm takes this concept and works out where tokens need to be
%%placed in the STG produced.
%
%Note: For better readability the format of concept scripts used in the article
%differs from the actual syntax used in our current implementation, which is
%embedded in Haskell programming language~\cite{1996_hudak_dsl} and therefore
%relies on the standard Haskell syntax. The basis of the format used here is the
%same, but there are some minor differences. An up-to-date description of the
%actual syntax supported by the developed tool can be found in the
%manual~\cite{2016_concepts_github}.
%
%%%Note: The code demonstrated in this example is the format required to work with
%%the tool.
%%%For the purpose of clarity, in this document we will be changing some of the
%%syntax when defining concepts.
%%%We will omit the module declaration, and imports, as well as
%%%the declaration of types for \emph{circuit}, as these are required, and as such
%%will be included in all concepts.
%%%\emph{rise} and \emph{fall} are used in the code to represent a high and low
%%transition respectively.
%%%We replace \emph{rise} with '+' and \emph{fall} with '-'. Finally, the diamond
%%composition operator in code is both a '<' and '>' as
%%%a diamond character is not a standard keyboard character. In this article, we
%%will use $\diamond$ to denote composition.
%%%All examples in this article are available in the
%%%format used by the tool from it's GitHub
%%repository~\cite{2016_concepts_github}.
%
%This set of concepts is only one way of describing this C-element
%and the environment. Another way could be to use gate-level concepts
%and describe the environment explicitly. In this case the environment
%allows the inputs to transition in the opposite direction to the output
%$c$, as two inverters would. We can then compose this with the C-element
%and the same \textsf{interface} and \textsf{initialState} concepts as follows:
%
%%\vspace{-3mm}
%\[
%\begin{array}{lcl}
%\mathsf{circuit}(a,b,c)&\hspace{-2mm}=&\hspace{-2mm}\mathsf{interface}~\diamond~\mathsf{cElement}(a,b,c)\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{environment}\diamond\mathsf{initialState}\\
%\mathsf{where}&~&~\\
%\,\,\,\,\,\,\mathsf{environment}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{inverter}(c,a)~\diamond~\mathsf{inverter}(c,b)
%\end{array}
%\]
%
%\noindent This specification is equivalent to the previous one; indeed one can
%prove this by rearranging the primitive concepts using the commutativity
%and associativity of the underlying commutative monoid. Consequently,
%this specification will be translated to the same STG shown in
%Figure~\ref{fig:cElement STG composition}.
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.25]{Images/stg-cElement}
%\par\end{centering}
%\protect\caption{\label{fig:cElement STG composition}STG for the example
%system.}
%%\vspace{-4mm}
%\end{figure}
%
%Finally, the designer can also rely on protocol-level concepts, producing
%the following equivalent specification:
%
%%\vspace{-3mm}
%\[
%\begin{array}{lcl}
%\mathsf{circuit}(a,b,c)&\hspace{-2mm}=&\hspace{-2mm}\mathsf{interface}\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{handshake00}(a,c)~\diamond~\mathsf{handshake00}(b,c)\\
%\end{array}
%\]
%
%\noindent Indeed, at the high level the circuit can be seen simply as two
%handshakes synchronised on a common signal.
%
%This example demonstrates that the presented formal notation for capturing
%concepts is very flexible and provides the designer with a rich selection
%of available levels of abstraction, which could be used not only for
%deriving simplest possible specifications but also for cross-checking
%the adequacy of specifications by \emph{refactoring} them according
%to the concept composition laws.
%
%%\vspace{-1mm}
%\subsection{Multiple behavioural scenarios\label{sub:scenarios}}
%
%So far we have only considered systems operating in a single behavioural
%\textit{scenario} specified by a composition of concepts. However,
%real-life systems often need to support multiple scenarios, e.g. start-up
%and normal operation, different power modes, etc. This allows
%each individual scenario to be designed using concepts,
%and tested individually to ensure they work correctly, before these
%are combined to produce a full system specification.
%
%To increase the reuse of scenarios, which helps reduce design
%time of future systems, this method supports the use of pre-designed
%scenarios as concepts.
%
%In some cases, a designer may find it easier to split the specification
%of operational modes further than scenarios and design certain elements
%separately. In this way, a model may be produced from concepts, which
%may not be an operational mode on its own, but can be composed and
%tested separately. Having several elements predefined
%using concepts may become useful for quickly designing systems. A
%predefined logic gate, for example, could be useful to quickly include
%in any list of concepts when designing multiple scenarios. An STG
%produced of this element can be referenced in a list of concepts by
%name (provided that the definition is appropriately imported into
%the current namespace). When a list of concepts is passed into the
%STG translation algorithm, all referenced concepts are replaced by
%the corresponding definitions.
%
%%The process of combining scenarios is explained further in
%\S~\ref{sub:scenario-composition}
%%\vspace{-1mm}

%\vspace{-3mm}
\section{Concepts to STG translation algorithm\label{sec:algorithm}}

Concepts are a useful way of specifying asynchronous circuits, but
specifications also need to be \emph{verified} against certain properties to
ensure their correctness, and once they are deemed to be correct, they need to
be \emph{synthesised} into efficient circuit implementations. Many software
tools exist which automatically verify and synthesise STG specifications,
such as \noun{Petrify}~\cite{Cortadella} and
\noun{Mpsat}~\cite{khomenko2004detecting}.

In order to reuse the tools developed by the community, it is
necessary to be able to automatically translate concept specifications to STGs.
In this section, we will display an example of how the translation algorithm 
operates, and present a pseudocode form of the algorithm in Algorithm~\ref{alg:translation}. 

%\vspace{-3mm}

\subsection{A translation example}

The example we will use for this is that of an OR-gate with control signal. 
This is similar to the OR-gate as seen in Section~\ref{sub:or-gate}; inputs
of $a$ and $b$, and an output of $c$. There will however be an extra 
input signal, $x$. 

This is the control signal, and interacts as follows:
Only when $x$ is high can the output $c$ transition. This control signals
allows a circuit to latch the output signal, by setting $x$ high to let
the output change, and when ready to use this signal, setting $x$ low,
so regardless of the inputs, it will remain in this state, and not change.

This is a rudimentary example, but is useful in displaying how the algorithm
handles a system featuring both OR- and AND-causality. The concept for 
the interaction of the control signal is:

%\vspace{-4mm}
\[
\begin{array}{lcl}
\mathsf{control}&\hspace{-2mm}=&\hspace{-2mm}x^{+} \rightsquigarrow c^{+} \diamond x^{+} \rightsquigarrow c^{-} 
\end{array}
\]

We know this signal is an input, and let's assume we would like to latch
the initially low output signal, and we can include this concept in the 
scenario for this translation:

%\vspace{-3mm}
\[
\begin{array}{lcl}
\hspace{-2mm}\mathsf{orGateCtrl}\,  a \, b \, c \, x &\hspace{-2mm}=&\hspace{-2mm}\mathsf{orGate}\, a\, b\, c \diamond\, \mathsf{control}
\diamond\, \mathsf{inputs}\, [a,\, b,\, x] \\
&& \diamond \, \mathsf{outputs} \,  [c] \diamond\, \mathsf{initialise0}\, [a,\, b,\, c,\, x]
\end{array}
\]

In this concept, we have reused the OR-gate concept, defined in Section~\ref{sub:or-gate}. 
For reference, the fully translated STG can be found in Figure~\ref{fig:or-gate-ctrl}.

%\vspace{-3mm}

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.25]{Images/or-gate-ctrl-stg}
\par\end{centering}
%\vspace{-1mm}
\protect\caption{\label{fig:or-gate-ctrl} OR-gate with control signal STG}
%\vspace{-3mm}
\end{figure}

This STG still contains the two $c^{+}$ transitions, allowing this transition when either 
$a^{+}$ or $b^{+}$ has occured. However, with the inclusion of $x$, note that both
of these transitions also require $x^{+}$ to have occured. This is the same for $c^{-}$. 
Through the addition of the \emph{control} concept, we need to add AND-causality to
each and every $c^{+}$ and $c^{-}$ transition with $x^{+}$. The combination of signals
required for each possible transition in both high and low transitions are calculated in the
algorithm, and we will detail this process in this section.

As displayed in Section~\ref{sec:examples}, there are multiple ways of
representing a specification using concepts. However, all levels of
abstraction available to the designer are built out of primitive low-level
signal concepts. Given a specification, we can therefore
break down all gate- and protocol-level constructs into `atoms', which
significantly simplifies the translation task.

For this example, the specification is broken down into these signal-level concepts:

%\vspace{-4mm}
\[
\begin{array}{lcl}
\hspace{-2mm}\mathsf{orGateCtrl}\,a,\,b,\,c\,x&\hspace{-2mm}=&\hspace{-2mm}[a^{+}, b^{+}]\sim\hspace{-1.5mm}|\hspace{-1.5mm}\sim\hspace{-1.5mm}>c^{+} 
\diamond a^{-}\rightsquigarrow c^{-} \diamond b^{-}\rightsquigarrow c^{-}\\
~&\hspace{-2mm}\diamond&\hspace{-2mm}x^{+}\rightsquigarrow c^{+} \diamond
x^{+}\rightsquigarrow c^{-} \diamond \mathsf{inputs} \, [a,\,b,\,x] \\
~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{outputs}\,[c]\diamond\mathsf{initialise0}\,[a,\,b,\,c,\,x]
\end{array}
\]

\noindent The first step is to prepare the read-arcs, and this is done by
reformating these concepts into lists of causes for effects.
Each list will be of possible causes for each OR- and AND-causality signal-level
concept in the specification, meaning that for each OR-causality concept, there will
be 2 or more signals in the list, and for each AND-causality concept there will be a single
item list. 

For example, using the concept $x^{+} \rightsquigarrow c^{+}$, for this $c^{+}$ transition,
there is only one possible cause of it, $x^{+}$. Therefore, this forms a single item list, 
containing only $x^{+}$.

For another example, taking the concept\\$[a^{+}, b^{+}]\sim\hspace{-1.5mm}|\hspace{-1.5mm}\sim\hspace{-1.5mm}>c^{+}$, there are
two possible transitions for $c^{+}$ here, $a^{+}$ and $b^{+}$. These therefore form 
a two item list. 

This will mean there may be several different lists for each cause transition. 
Table~\ref{tab:list-of-concepts} contains all of the lists described above.

\begin{table}[h]
\caption{Lists of possible cause transitions for effect transitions\label{tab:list-of-concepts}}

  \centering
\begin{tabular}[htb]{| m{2.6cm} | m{2.0cm} |}
  \hline
Causes & \, Effect \\ \hline \hline
$x^{+}$ & $c^{+}$ \\ \hline
$a^{+}$, $b^{+}$ & $c^{+}$ \\ \hline
$x^{-}$ & $c^{-}$ \\ \hline
$a^{-}$ & $c^{-}$ \\ \hline
$b^{-}$ & $c^{-}$ \\ \hline
  \end{tabular}
  %\vspace{-3mm}
\end{table}

\noindent From this, we can then combine the lists by effect transition, to give us a list of lists.
This can be viewed in Table~\ref{tab:list-of-lists}

\begin{table}[h]
\caption{Lists of lists of cause transitions for effect transitions\label{tab:list-of-lists}}

  \centering
\begin{tabular}[htb]{| m{2.6cm} | m{2.0cm} |}
  \hline
Causes & \, Effect \\ \hline \hline
[$x^{+}$], [$a^{+}$, $b^{+}$] & $c^{+}$ \\ \hline
[$a^{-}$], [$b^{-}$], [$x^{-}$] & $c^{-}$ \\ \hline

  \end{tabular}
  %\vspace{-1mm}
\end{table}

\noindent Note how for the $c^{-}$ transition there is 3 different single item 
lists. Each one is an AND-causality, and why they are each in a separate list
will become apparent in the next step. 

This step is applying the \emph{Cartesian Product} to each the list of lists
for each effect transition. This will "expand the brackets", combining each
item of each list with every item of every other list, creating a single list which
provides us with the number of this transition and  whicharcs to connect 
for each transition of each type. 
For example, using the list of lists for $c^{+}$:

%\vspace{-3mm}
\[
\begin{array}{lcl}
~&[a^{+}, b^{+}]\, [x^{+}] = [a^{+} x^{+}, b^{+} x^{+}]
\end{array}
\]

\noindent In this example, we combine every item in the first list,
$[a^{+}, b^{+}]$, with every item in the second list, which only 
contains $x^{+}$. This will therefore give us a new 2 item list. 

This list provides us with both the number of $c^{+}$ transitions,
2, and which transitions are the causes of each of these transitions.
The first $c^{+}$ transition will be caused by $a^{+}$ and $x^{+}$,
the second will be caused by $b^{+}$ and $x^{+}$. 

For $c^{-}$, the result of the cartesian product will be a single item,
as combining each item in each list will combine all three of the items 
at once. This will be as follows:

%\vspace{-3mm}
\[
\begin{array}{lcl}
~&[a^{-}], [b^{-}], [x^{-}]  = [a^{-} b^{-} x^{-}]
\end{array}
\]

\noindent There will therefore be only one $c^{-}$ transition, requiring all three
of $a^{-}$, $b^{-}$ and $x^{-}$ to have occured before $c^{-}$
can occur. 

Now, we can list the read-arcs to be connected for each transition of $c$.
This can be viewed in Table~\ref{tab:list-by-transition}.

\begin{table}[h]
\caption{List of all effect transitions and their causes\label{tab:list-by-transition}}

  \centering
\begin{tabular}[htb]{| m{2.6cm} | m{2.0cm} |}
  \hline
Causes & \, Effect \\ \hline \hline
$a^{+}$, $x^{+}$ & $c^{+}(0)$ \\ \hline
$b^{+}$, $x^{+}$ & $c^{+}(1)$ \\ \hline
$a^{-}$, $b^{-}$, $x^{-}$ & $c^{-}$ \\ \hline
  \end{tabular}
  %\vspace{-1mm}
\end{table}

The numbers of the $c^{+}$ transitions are necessary for reference
when definining arcs, for example, $b^{+}$ needs to connect to 
$c^{+}(1)$, not $c^{+}(0)$ or just $c^{+}$ as this can cause 
erroneous arcs to be included. 

For clarity, where there is only one transition, such as with $c^{-}$
we will refer to this simply as $c^{-}$, but this is effectively $c^{-}(0)$.

This concludes the part of the algorithm which defines the arcs
and transitions. Next, the algorithm begins to build the STGs. 

First of all, we need to add places for each signal. These are used to
show whether a signal has transitioned high or low at any point. 
A token in a $0$ place for example shows that that signal has 
transitioned low. We add a $0$ and $1$ place for each signal, 
which for this example gives us $a0$, $a1$, $b0$, $b1$, $x0$, $x1$
$c0$ and $c1$.

%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.25]{Images/or-gate-ctrl-places-stg}
%\par\end{centering}
%%\vspace{-1mm}
%\protect\caption{\label{fig:places} Places in an STG during translation}
%%\vspace{-3mm}
%\end{figure}

The interface is defined at the start of the algorithm, by listing them as $inputs$,
$outputs$ or $internals$, so now we need to include all the transitions, and
connect these to the places to form consistency loops, to ensure that all signals 
in this system can only transition in one way when this signals previous transition
was in the opposite direction. 

This is done by taking each transition, and if it is a $+$ transition, connecting 
the $0$ place for this signal to the transition, then connecting this transition to 
the $1$ place for this signal. Conversely, if it is a $-$ transition, we connect the
$1$ place for this signal to the transition, and connect this transition to the $0$ 
place. Including these will form an STG as shown in Figure~\ref{fig:loops}. Note
that both $c^{+}$ transitions are included in these loops.

\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.25]{Images/or-gate-ctrl-loops-stg}
\par\end{centering}
%\vspace{-1mm}
\protect\caption{\label{fig:loops} STG containing only consistency loops}
%\vspace{-3mm}
\end{figure}

Now the algorithm introduces the initial states. All of the signals are specified
to be initially 0, meaning that the first transition will be the $+$. From the
consistency loops, to allow this to happen, we need to place a token in each 
$0$ place for each signal. This will produce the STG displayed in Figure~\ref{fig:tokens}.


\begin{figure}[h]
\begin{centering}
\includegraphics[scale=0.25]{Images/or-gate-ctrl-inits-stg}
\par\end{centering}
%\vspace{-1mm}
\protect\caption{\label{fig:tokens} STG containing consistency loops and initial states}
%\vspace{-3mm}
\end{figure}

Finally, we can add the connections to the transitions, and cause the 
expected interaction between signals. We use read-arcs to connect the effect
transitions to the places after the transition of the cause. For example, for
$x^{+} \rightsquigarrow c^{+}$, we will connect the $x1$ place to the 
transition of $c^{+}$. We use read-arcs for these, as for this example, only
after $c^{+}$ has occured, and placed a token in $x1$, will $c^{+}$ be allowed
to occur, but the read arc will not consume the token in $x1$ which would block
$x^{-}$ from being able to occur. 

Following this, the specification is fully translated, and the resulting STG will
be the same as shown in Figure~\ref{fig:or-gate-ctrl}.

%%\vspace{-3mm}
%\[
%\begin{array}{lcl}
%\hspace{-2mm}\mathsf{circuit}(a,b,c)&\hspace{-2mm}=&\hspace{-2mm}a^{+}\rightsquigarrow
%c^{+} \diamond b^{+}\rightsquigarrow c^{+} \diamond c^{+}\rightsquigarrow a^{-}
%\diamond c^{+}
%\rightsquigarrow b^{-}\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}a^{-}\rightsquigarrow c^{-} \diamond
%b^{-}\rightsquigarrow c^{-} \diamond c^{-}\rightsquigarrow a^{+} \diamond
%c^{-}\rightsquigarrow b^{+}\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{initialise}(a,0) \diamond
%\mathsf{initialise}(b,0) \diamond \mathsf{initialise}(c,0)\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{inputs}(\{a,b\})\diamond\mathsf{outputs}(\{c\})
%\end{array}
%\]
%%\vspace{2mm}
%\noindent One can see that the above list of primitive concepts matches
%the STG in Figure~\ref{fig:cElement STG composition} very closely, in particularthe causality concepts match the arcs of the STG. Below we describe a general
%translation algorithm that in particular can produce this STG fully
%automatically.
%The algorithm is implemented and integrated in the open-source tool
%\noun{Workcraft},
%where it produces STGs in commonly used \textsf{*.g} file format.

%Given a list of primitive concepts, the algorithm starts by creating so-called
%\emph{consistency loops} for each signal in the specified interface, which
%forces rising
%and falling transitions of each signal to alternate, thereby ensuring that the
%resulting
%STG satisfies the property of \emph{consistency}~\cite{Cortadella}.
%The places between the transitions of a signal determine its state.
%Figure~\ref{fig:step-by-step1} shows consistency loops created for the example.
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.23]{Images/Step-by-step1}
%\par
%\protect\caption{\label{fig:step-by-step1}The first step: create consistency
%loops.}
%%\vspace{-2mm}
%\end{centering}
%\end{figure}
%
%The next step is to connect signal transitions according to the list of
%causality
%concepts. In the above example we start with $a^{+}\rightsquigarrow c^{+}$.
%To represent it in the STG, we connect the place after $a^{+}$ ($a_1$ in
%Figure~\ref{fig:step-by-step1}) to transition $c^{+}$ by a \emph{read arc},
%which allows $c^{+}$ to transition without consuming the token (consuming
%the token would disable $a^{-}$), see Figure~\ref{fig:step-by-step2}.
%
%%\vspace{-2mm}
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.23]{Images/Step-by-step2}
%\par
%\protect\caption{\label{fig:step-by-step2}The second step: add causality concept
%$a^{+}\rightsquigarrow c^{+}$.}
%%\vspace{-2mm}
%\end{centering}
%\end{figure}
%
%We continue translating the remaining causality concepts in the same manner
%obtaining the STG shown in Figure~\ref{fig:step-by-step9}.
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.23]{Images/Step-by-step9}
%\par
%\protect\caption{\label{fig:step-by-step9}Finish the second step: add all
%causality concepts.}
%%\vspace{-2mm}
%\par\end{centering}
%\end{figure}
%
%The final step of the translation algorithm is to add tokens to some of the
%places
%of the resulting STG according to the initial state concepts
%$\mathsf{initialise}(a,0) \diamond \mathsf{initialise}(b,0) \diamond
%\mathsf{initialise}(c,0)$, which declare the initial states of all three signals
%to be 0. We therefore
%add tokens to places $a_0$, $b_0$ and $c_0$, producing the fully translated STG
%in
%Figure~\ref{fig:step-by-step12}.
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.23]{Images/Step-by-step12}
%\par
%\protect\caption{\label{fig:step-by-step12}The final step: set the initial
%state.}
%\par\end{centering}
%%\vspace{-3mm}
%\end{figure}
%
%The resulting STG and the STG shown above
%look very different but they are behaviourally equivalent. The latter is much
%more
%compact and easier to read though, and it would be preferable to show it to the
%designer instead of the one obtained by our translation algorithm. Our
%implementation supports automated \emph{resynthesis} of the resulting STG
%using \noun{Petrify}, and can therefore seamlessly produce the STG above 
%from the given specification.
%
%%%By integrating concepts into \noun{Workcraft} we allow a designer to
%%%visualise their concept designs as STGs, to simulate, verify and synthesise
%%them,
%%%and if there are any corrections or additions to be made these can be done
%%either
%%%directly in the STG or in the original concept specification, which can then
%%%be re-translated into an updated STG.
%
%%%In some cases it may not be necessary to visualize a translated STG. A
%%\emph{.g} file is used as an input with these tools, without having to import
%%into \noun{Workcraft}. This can
%%%further quicken the process of specification using concepts. This also applies
%%to synthesis, which can be performed using a tool such as \noun{Petrify} or
%%\noun{Mpsat}.
%%
%%%or using \emph{Direct Synthesis}, which is discussed in
%%\S\ref{sub:direct-synth}.
%
%The described translation algorithm is shown in pseudocode
%in~Algorithm~\ref{alg:translation}.

%\vspace{-1mm}

\begin{algorithm}[H]
\begin{algorithmic}
\caption{Algorithm for translating concepts to STGs\label{alg:translation}}
\For {Signal $s$ in \textbf{System}}
  \State \textbf{define} interface of $s$ as \emph{Input/Output/Internal}
\EndFor

\For {Each effect transition $e$}
  \State $allCauses$ $\leftarrow$ Concatinate lists of possible causes for $e$
  \State $transitionList$ $\leftarrow$ \emph{Cartesian Product} \textbf{of} $allCauses$
  \For {$i = 0$ to Length of $transitionList$}
    \State \textbf{add} $e(i)$ to $transitions$
  \EndFor 
\EndFor
\For {Each \textbf{signal} $s$ in system}
  \State \textbf{add} place \textbf{$s$.Name}$0$
  \State \textbf{add} place \textbf{$s$.Name}$1$
\EndFor
\For {Each \textbf{transition} $t$ in $transitions$}
  \If {transition is high}
    \State \textbf{connect} (place $t$.signalName$0$, transition)
    \State \textbf{connect} (transition, place $t$.signalName$1$)
    \For {Each \textbf{cause transition} $c$ for $t$}
      \State \textbf{read-arc} (place $t$.signalName$1$, $c$)
    \EndFor
  \EndIf
  \If {transition is low}
    \State \textbf{connect} (place $t$.signalName$1$, transition)
    \State \textbf{connect} (transition, place $t$.signalName$0$)
    \For {Each \textbf{cause transition} $c$ for $t$}
      \State \textbf{read-arc} (place $t$.signalName$0$, $c$)
    \EndFor
  \EndIf
\EndFor
\For {Each initial state $state$ concept}
  \If {$state$ is low}
    \State \textbf{add-token}(\textbf{signalName.place}$0$)
  \EndIf 
  \If {$state$ is high}
    \State \textbf{add-token}(\textbf{signalName.place}$1$)
  \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

%\begin{algorithm}[t]
%\begin{algorithmic}
%\caption{Algorithm for translating concepts to STGs\label{alg:translation}}
%\For {Each defined concept}
%  \State \textbf{add} signal-level concepts \textbf{to} conceptList
%\EndFor
%%//Create consistency loops
%\For {Each signal in system}
%  \State \textbf{define} signal as input/output/internal
%  \State \textbf{add} transition \textbf{high}
%  \State \textbf{add} transition \textbf{low}
%  \State \textbf{add} place \textbf{signal-0}
%  \State \textbf{add} place \textbf{signal-1}
%  \State \textbf{connect} (transition \textbf{high}, place \textbf{signal-1})
%  \State \textbf{connect} (place \textbf{signal-1}, transition \textbf{low})
%  \State \textbf{connect} (transition \textbf{low}, place \textbf{signal-0})
%  \State \textbf{connect} (place \textbf{signal-0}, transition \textbf{high})
%\EndFor
%
%\For {Each causlity concept}
%\State \textbf{connect-read}(place \textbf{following} cause, effect transition)\EndFor
%
%\For {Each initial state concept}
%  \State \textbf{add-token}(place \textbf{signal-}value)
%\EndFor
%
%\end{algorithmic}
%\end{algorithm}

%\subsection{Partial translation and parallel composition}
%
%In some cases it may be useful to partially translate concepts to STGs, for
%example to investigate the behaviour of a circuit
%in different environments. An important property of the above algorithm is
%that it can be applied to incomplete systems, thereby translating
%smaller collections of concepts, or even singular concepts, which do not
%necessarily correspond to well-behaving STGs (e.g. the resulting STGs may
%contain
%spurious input transitions if they are not controlled by the environment).
%Such partial specifications can be visualised, studied, and then composed into
%complete specifications using the \emph{parallel composition}, which is
%supported
%by \noun{Workcraft} using an integrated tool \noun{Pcomp}~\cite{PCOMP}.
%
%\begin{figure}[t]
%\begin{centering}
%\subfloat[\label{fig:cElement}$\mathsf{cElement}(a,b,c)$]{\begin{centering}
%\includegraphics[scale=0.23]{Images/C-element}
%\par\end{centering}
%}
%\par
%\subfloat[\label{fig:inverterca}$\mathsf{inverter}(c,a)$]{\begin{centering}
%\includegraphics[scale=0.23]{Images/inverter(c,a)}
%\par\end{centering}
%
%}
%\par
%\subfloat[\label{fig:inverterba} $\mathsf{inverter}(c,b)$]{\begin{centering}
%\includegraphics[scale=0.23]{Images/inverter(c,b)}
%\par\end{centering}
%}
%\par\end{centering}
%\protect\caption{\label{fig:IndividConceptStgs}Partial translation of concepts
%into STGs}
%%\vspace{-6mm}
%\end{figure}
%
%Using the example of, a C-element with
%environment,
%we can translate the concepts corresponding to the C-element and the two
%environment inverters individually. Including the initial states, this would
%give us the STGs found in Figure~\ref{fig:IndividConceptStgs}. These STGs 
%can becomposed using the parallel composition, the outcome of which will be equivalent
%to the result obtained by translating the complete specification, bringing us
%back
%to the STG in an earlier section. 

%\subsection{Scenario combination\label{sub:scenario-composition}}
%
%As mentioned in Section~\ref{sub:scenarios}, concepts are used to specify
%a single behavioural scenario.
%which can be tested and verified separately to allow for easier changes and additions 
%to smaller, less complex, specifications. However, when scenarios are tested and
% prove to work as required, and satisfy all necessary properties, they then need 
%to be combined to produce a full system specification, so this can be tested and 
%verified, and ultimately be synthesized to produce an implementation. 
%When combining scenarios, there are several things to consider in how the scenarios fit together.
%Depending on the application, the circuit is being designed for
%some scenarios may need to operate in certain
%orders, for example, one scenario may exist simply to initialise the
%circuit, therefore this scenario needs to run at start-up, before
%any other scenario, and then never be run again while the
%system remains active.
%
%To address this, we can define \emph{templates},
%which can be used to combine scenarios in various ways.
%With this the designer specifies how the scenarios should
%be combined, and if an order is needed, the order the scenarios should
%be run from start up. The following are some examples of templates
%that can be used to combine scenarios:
%
%\textbf{Sequential template:} Sequential combination will allow a designer
%to select the order of all scenarios, so when combined, they will
%run in a sequence. In this case, there may be a clear order in which
%the scenarios may run, and this needs to be specified by the designer:
%
%%\vspace{-2mm}
%\begin{center}
%\includegraphics[scale=0.42]{Images/sequential_combination}
%\end{center}
%
%\textbf{Concurrent template:} In this case there is no order, but one or more
%of the scenarios in a specification may run concurrently. It may be necessary
%to limit concurrency by specifying, for instance, the number of scenarios
%that can be active simultaneously:
%
%%\vspace{-2mm}
%\begin{center}
%\includegraphics[scale=0.42]{Images/concurrent_combination}
%\end{center}
%
%\textbf{Non-deterministic choice template:} This template will combine the
%scenarios in a way that allows any of the scenarios to run, but not
%according to any order to deal with the lack of determinism in the
%system, using one token which is used only by the running scenario,
%and returned when the scenario completes:
%
%%\vspace{2mm}
%\begin{center}
%\includegraphics[scale=0.42]{Images/non_deterministic_combination}
%\end{center}
%
%There may be more complex requirements to combination of scenarios, and it
%is possible to combine some scenarios using one template, then including
%the result in a combination with other scenarios using another template.
%For example, a system which is non-deterministic may also have a scenario
%that runs at start up. In this case, a designer could combine all
%non-deterministic scenarios first, then combine the resulting STG with
%the initialising scenario, setting the order so this runs first.
%
%This method can allow for many possible scenario combination
%styles, and more complex systems can be combined automatically, which
%in comparison to manual combination, could reduce the number of errors
%as well as design time.

%\vspace{-2mm}

\subsection{Interoperability with STG based tools \label{sub:interop-with-stg}}

%%\vspace{-5mm}
%\begin{figure*}[h]
%\begin{centering}
%\includegraphics[scale=0.3]{Images/design_flow_wc_screenshot}
%\par\end{centering}
%
%\protect\caption{\label{fig:workcraft_screenshot}Stages of the design flow when
%using asynchronous concepts in \noun{Workcraft}.}
%%\vspace{-4mm}
%\end{figure*}

The concepts tool, which translates asynchronous concepts to STGs has been
integrated into open-source toolsuite \noun{Workcraft}~\cite{Workcraft_website}.
This allows a designer to visualise their concept designs as STGs, to simulate,
verify and synthesise them using other tools integrated in \noun{Workcraft},
such as \noun{Petrify}~\cite{Cortadella} and
\noun{Mpsat}~\cite{khomenko2004detecting}.
If there are any corrections or additions to be made these can be done
either directly in the STG or in the original concept specification, which can then
be re-translated into an updated STG. These automated processes can allow for a
streamlined design process of asynchronous circuits.

The translation tool itself produces a \emph{.g} document format, which is a
graph format used to store STG information. This means that it is not
necessary to view the STG after translation, and a concept specification
can be used directly after translation with these tools. 

%Scenario combination is not yet implemented and is performed manually by
%the designer using \noun{Workcraft}'s graphical user interface. This
%design stage can also be automated to further streamline the design process
%using concepts.


%%\subsection{Direct synthesis from concepts \label{sub:direct-synth}}
%%
%%%It is possible to synthesise directly from STGs, which we call \emph{Direct
%%Synthesis}. Direct synthesis is a method of producing an implementation directly
%%from concepts, finding Boolean
%%functions which are used to produce a logic gate implementation. There are some
%caveats to this however. Currently, it is suboptimal, and thus the functions it
%produces may not be the
%%best possible implementation, but it may be a quicker method of finding an
%implementation. We will explain this algorithm in this section, and give a brief
%example.
%%
%%\subsubsection{Algorithm of direct synthesis}
%%
%%When finding an implementation for a specification, we need only concern
%ourselves with the output signals. The input signals, the environment, can not
%be
%%controlled directly by a circuit, it merely reacts to the outputs, but we need
%to find a way of causing the outputs to changed based on the inputs. In this way
%we only need to find the
%%Boolean equations for the output signals.
%%
%%Therefore, we take an output signal, $x$. With this, we start by finding all
%concepts in which a signal causes a low to high transition, also known as the
%set function, $x^{+}$, such as
%%$p\rightsquigarrow x^{+}$, where p is any signal transition. We then record
%these signals only for $x^{+}$ in the form of a Boolean equation, where a low to
%high signal transition, such
%%as $p^{+}$ would be recorded as simply $p$, and a high to low transition,
%$p^{-}$, would be recorded as $\bar{p}$. All signals which cause this output
%signal transition in this scenario
%%will be combined using the \emph{AND} ($*$) operation.
%%
%%This is then repeated to find the equations for the opposite transition for
%this output signal, in this case the high to low transition, $x^{-}$, also known
%as the reset function. Following
%%this, we can reduce these equations. First of all, by resolving some Boolean
%relations. A Boolean relation is when an equation contains several signals which
%are related, usually by a
%%transition of one being assumed to occur after the transition of
%another~\cite{Cortadella}. For example, take a system with two input signals,
%$p$ and $q$, and an output signal $x$. If
%%some concepts in this system are:
%%
%%%\vspace{2mm}
%%\begin{minipage}[t]{1\columnwidth}%
%%\begin{center}
%%$\,p^{+}\rightsquigarrow x^{+}$
%%\par\end{center}
%%
%%\begin{center}
%%$\,q^{+}\rightsquigarrow x^{+}$
%%\par\end{center}
%%
%%\begin{center}
%%$\,p^{+}\rightsquigarrow q^{+}$
%%\par\end{center}
%%
%%\end{minipage}%\vspace{2mm}
%%
%%The equation for $x^{+}$ will contain in some variation $p*q$. These concepts
%state that both $p^{+}$ and $q^{+}$ must occur before $x^{+}$ can occur. It also
%states, however,
%%the timing assumption that $p^{+}$ occurs before $q^{+}$. It can therefore be
%assumed that $q^{+}$ shows that the $p^{+}$ transition has occurred, and can be
%removed from the
%%Boolean equations.
%%
%%Further reductions can be performed on these equations using existing
%algorithms, which will remove any redundancies and simplify them. The set and
%reset functions for
%%this signal can then be used for a logic implementation. Depending on the type
%of synthesis these can be used in different ways, for instance, C-element
%synthesis uses these set and
%%reset functions as they are, but technology mapping combines these functions by
%negating only the signals in the reset function, not the equation itself, and
%then \emph{OR}-ing this
%%with the set function of $x^{+}$. This can then be combined with an existing
%equation for $x$ from previous scenarios by \emph{OR}-ing this with the existing
%equation.
%%
%%This can be repeated for each output signal in the scenario, and for each
%scenario in the specification, and this will produce a full implementation for
%the system. An algorithm for Direct
%%Synthesis is found in Algorithm~\ref{alg:direct-synth}
%%
%%\begin{algorithm}[h]
%%\begin{algorithmic}
%%\caption{Algorithm for direct synthesis \label{alg:direct-synth}}
%%\For {Each scenario in system}
%%  \For {Output signal $x$ in all output signals}
%%    \For {Each signal transition $p$ that causes $x^{+}$}
%%	\If {$p^{+}$}
%%                \State setEq <- setEq $*$ $p$;
%%          \Else
%%	     \State setEq <- setEq  $*$ $\bar{p}$
%%	\EndIf
%%    \EndFor
%%    \For {Each signal transition $p$ that causes $x^{-}$}
%%         \If {$p^{+}$}
%%                \State resetEq <- resetEq  $*$  $p$;
%%          \Else
%%	     \State resetEq <- resetEq  $*$  $\bar{p}$
%%	\EndIf
%%    \EndFor
%%  \EndFor
%%  \State reduce(setEq)
%%  \State reduce(resetEq)
%%\EndFor
%%\end{algorithmic}
%%\end{algorithm}
%%
%%\subsubsection{Example of direct synthesis}
%%
%%For this example we will use the same example as we have previously, the
%C-element with environment~(Figure~{\ref{fig:cElement-concepts}). In the case of
%a circuit for this example,
%%the inputs $a$ and $b$ we cannot control, and thus it is assumed that the
%environment will correctly invert the output, $c$, to produce these input
%signals.
%%
%%Using the list of concepts found in Figure~\ref{fig:c-element-concepts}, we can
%find the set and reset functions for the only output signal $c$.
%%
%%%\vspace{2mm}
%%\begin{minipage}[t]{1\columnwidth}%
%%\begin{center}
%%$\,c^{+}: a * b$
%%\par\end{center}
%%
%%\begin{center}
%%$\,c^{-}: \bar{a} * \bar{b}$
%%\par\end{center}
%%
%%\end{minipage}%\vspace{2mm}
%%
%%These functions are fairly simple in this example, and there are no further
%simplification to be done, and thus these can be used for synthesis. In this
%case, as we are aiming to use a
%%C-element in the implementation, and thus we can use C-element synthesis. The
%synthesis of this will produce the implementation found in
%Figure~\ref{fig:c-element-gate}
%%
%%\begin{figure}[h]
%%\begin{centering}
%%\includegraphics[scale=0.65]{Images/C-element-gate}
%%\par\end{centering}
%%
%%\begin{centering}
%%\protect\caption{\label{fig:c-element-gate}Implementation of C-element with
%environment}
%%
%%\par\end{centering}
%%
%%\end{figure}
%
%%%+ Algorithm for translating concepts to STGs
%%%
%%%+ Using parallel and scenario composition to produce STGs for the whole system%%
%%%+ Direct synthesis from concepts
%%\section{NEED TO REMOVE: Synthesis of STGs from concepts
%\label{sec:Synthesis-of-STGs}}
%%
%%%\vspace{-3mm}
%%\textbf{This section needs to be edited to be included in section
%\ref{sec:interop-with-stg}}
%
%%\vspace{5mm}
%
%When a list of concepts is produced, we then pass this into an algorithm
%which converts these into a single scenario STG that, if possible,
%satisfies all of the concepts. This STG represents one operational
%mode of a full specification, and this needs to be combined with other
%scenario STGs in order to produce a full system specification. In
%this section we will discuss how this process is performed, from concepts,
%to a set of scenario STGs, to a full system model.
%
%%\vspace{-2mm}
%
%
%
%\subsection{Deriving STG fragments from concepts}
%
%%\vspace{-2mm}
%
%
%The algorithm begins by expanding any predefined concepts, and this
%returns a full list of concepts. Each concept can then be converted
%into its own STG fragment. In some cases, a single concept can represent
%a single STG fragment, but if a one-to-many concept is used, multiple
%fragments can be produced. These fragments are all created and stored
%for use in the next step, but hidden from the user. However, how the
%fragments are produced is important. For example, an STG fragment
%converted from the concept \textsf{\textit{\emph{outputRise}}} in
%the above C-element example is shown in Figure~\ref{fig:outputRise STG}.
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.23]{Images/outputRise-stg}
%\par\end{centering}
%
%\protect\caption{\label{fig:outputRise STG}STG for the
%\textsf{\textit{\emph{outputRise}}}
%concept.}
%\end{figure}
%
%
%This STG features arcs which suggest that \textsf{$a^{+}$} and $b^{+}$
%must occur before \textsf{$c^{+}$}, as the concept suggests. This
%fragment can also be seen as part of the scenario STG in
%Figure~\ref{fig:cElement STG}.
%This concept however features two back-pressure arcs which are not
%necessarily described in the concept. In order for fragments created
%from concepts to be usable in producing scenario STGs, they need to
%be complete, meaning they must have initial states, displayed using
%tokens, and must not reach deadlock at any point, and this STG would
%be incomplete without these back-pressure arcs used to show initial
%states. These arcs are produced automatically by the algorithm, and
%these fragments may be hidden from the user.
%
%%\vspace{-3mm}
%
%
%
%\subsection{Scenario STGs}
%
%%\vspace{-2mm}
%
%
%If all concepts can be correctly converted into STG fragments, then
%they can then be used to produce the STG for the scenario. This process
%is done using a tool integrated in \noun{Workcraft} called
%\noun{Pcomp~}\cite{PCOMP},
%which is designed to compose multiple STGs. The algorithm will automatically
%take all STG fragments and pass them into the \noun{Pcomp} tool, and
%this returns a single STG, created by composing all of the fragments.
%It is necessary for all STG fragments to be complete, for example
%using back-pressure arcs and including the initial states, as this
%is used in the parallel composition process.
%
%We can use this process to produce STGs for scenarios, which are then
%verified and simulated in \noun{Workcraft} and used in the next step.
%However, if this STG is not to be used as a scenario but as a predefined
%concept, this can be verified and stored for further use as part of
%scenario descriptions.
%
%%\vspace{-3mm}
%
%
%
%\subsection{Combination of scenarios \label{sub:Combination-of-scenarios}}
%
%%\vspace{-3mm}
%
%
%When a scenario STG has been produced and verified, it can then be
%combined with other scenarios to produce a complete circuit specification.
%
%When combining scenarios, there are several things to consider in
%how the scenarios fit together. Depending on the application the circuit
%is being designed for, some scenarios may need to operate in certain
%orders, for example, one scenario may exist simply to initialise the
%circuit, therefore this scenario needs to run at start-up, before
%any of the other scenarios, and then never be run again while the
%system remains active.
%
%To address this, when combining scenarios we offer some templates,
%each of which can be used to combine scenarios in various orders.
%With this the designer specifies in which ways the scenarios should
%be combined, and if an order is needed, the order the scenarios should
%be run from start up. The following are some examples of templates
%that will be offered before scenarios are combined:
%
%\textbf{Sequential:} Sequential combination will allow a designer
%to select the order of all scenarios, so when combined, they will
%run in a sequence. In this case, there may be a clear order in which
%the scenarios may run, and this needs to be specified by the designer.
%
%\textbf{Concurrent:} In this case there is no order, but one or more
%of the scenarios in a specification may run in parallel. This template
%will combine the scenarios in a way that will allow concurrency to
%occur, limited to requirements of the specification, for instance,
%the number of scenarios that can be active at any one time, which
%can be limited by the number of tokens available at once.
%
%\textbf{Non-deterministic choice:} This template will combine the
%scenarios in a way that allows any of the scenarios to run, but not
%according to any order to deal with the lack of determinism in the
%system, using one token which is used only by the running scenario,
%and this is returned when the scenario completes.
%
%There may be some more complex requirements to combination, and it
%is possible to combine some scenarios using one template, then including
%the result in a combination using another template. For example, a
%system which is non-deterministic may also have a scenario that runs
%at start up to initialise the system. In this case, a designer could
%combine all non-deterministic scenarios first, then combine the resulting
%STG with the initialising scenario, setting the order so this runs
%first.
%
%This method of combination can allow for many possible scenario combination
%styles, and more complex systems can be combined automatically, which
%in comparison to manual combination, could reduce the number of errors
%as well as design time.
%
%%\vspace{-3mm}
%
%

%%\vspace{-1mm}
%\section{Case study\label{sec:case-study}}
%
%In Section~\ref{sec:Motivating Example} we introduced the motivating example forthis article, a simple buck converter, and discussed the challenges of
%monolithic
%approach to specifying asynchronous circuits. We have also introduced
%concepts in Section~\ref{sec:Concepts}, and with examples explained how they canbe used to design simple circuits, and how these can be translated to STGs
%for subsequent synthesis of asynchronous gate-level implementation.
%In this section we use the buck converter as a case study to detail the
%whole design process in \noun{Workcraft}, see
%Figure~\ref{fig:workcraft_screenshot}.
%
%%%\vspace{-5mm}
%\begin{figure*}[t]
%\begin{centering}
%\includegraphics[scale=0.5]{Images/design_flow_wc_screenshot}
%\par\end{centering}
%
%\protect\caption{\label{fig:workcraft_screenshot}Stages of the design flow when
%using asynchronous concepts in \noun{Workcraft}.}
%%\vspace{-4mm}
%\end{figure*}
%
%\subsection{Formal specification using concepts}
%
%The informal specification of the buck converter defines three operating modes
%that require distinctive control scenarios. Requirements for each operating modecan be captured with a separate list of concepts and translated into scenario
%STGs. These can be subsequently combined to produce single STG for the whole
%circuit.
%During this process, it is useful to find any operations which occur
%between two or more operating modes, as these can then be reused.
%
%\subsubsection{ZC~absent scenario}
%
%A circuit that handles buck operation in absence of ZC condition is specified as
%follows:
%
%%\vspace{-4mm}
%\[
%\mathsf{zcAbsentScenario}(uv,oc,zc,gp,gp\_ack,gn,gn\_ack)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%\]
%%\vspace{-6mm}
%\[
%~~=~\mathsf{chargeFunc}~\diamond~\mathsf{uvFunc}~\diamond~\mathsf{uvReact}
%\]
%%\vspace{-5mm}
%\[
%\begin{array}{lcl}
%\mathsf{where}&~&\\
%
%~~~~\mathsf{interface}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{inputs}~[uv, oc, zc,
%gp\_ack, gn\_ack]\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{outputs}~[gp, gn]\\
%
%~~~~\mathsf{uvFunc}&\hspace{-2mm}=&\hspace{-2mm}uv^{+}\rightsquigarrow
%gp^{+}~\diamond~ uv^{+}\rightsquigarrow gn^{-}\\
%
%~~~~\mathsf{ocFunc}&\hspace{-2mm}=&\hspace{-2mm}oc^{+}\rightsquigarrow
%gp^{-}~\diamond~ oc^{+}\rightsquigarrow gn^{+}\\
%
%~~~~\mathsf{uvReact}&\hspace{-2mm}=&\hspace{-2mm}gp\_ack^{+}\rightsquigarrow
%uv^{-}~\diamond~gn\_ack^{-}\rightsquigarrow uv^{-}\\
%
%~~~~\mathsf{ocReact}&\hspace{-2mm}=&\hspace{-2mm}gp\_ack^{-}\rightsquigarrow
%oc^{-}~\diamond~gn\_ack^{+}\rightsquigarrow oc^{-}\\
%
%~~~~\mathsf{environment}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{me}(uv, oc)\\
%
%~~~~\mathsf{\mathsf{noShortcircuit}}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{me}(gn,
%gp)\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}gn\_ack^{-}\rightsquigarrow
%gp^{+}~\diamond~gp\_ack^{-}\rightsquigarrow gn^{+}\\
%
%~~~~\mathsf{gpHandshake}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{handshake}(gp,gp\_ack)\\
%
%~~~~\mathsf{gnHandshake}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{handshake}(gn,gn\_ack)\\
%
%~~~~\mathsf{initialState}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{initialise0}~[uv,oc,zc,gp,gp\_ack]\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{initialise1}~[gn,gn\_ack]\\
%
%~~~~\mathsf{chargeFunc}&\hspace{-2mm}=&\hspace{-2mm}\mathsf{interface}~\diamond~\mathsf{ocFunc}~\diamond~\mathsf{ocReact}\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{environment}~\diamond~\mathsf{noShortcircuit}\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{gpHandshake}~\diamond~\mathsf{gnHandshake}\\
%~&\hspace{-2mm}\diamond&\hspace{-2mm}\mathsf{initialState}
%
%\end{array}
%\]
%
%The \textsf{zcAbsentScenario} concept is a composition of buck charging and UV
%handling.
%Consider the charging function captured in \textsf{chargeFunc} concept.
%It comprises several concepts: \textsf{interface} specifies the types
%of signals and \textsf{initialState} defines their initial state;
%\textsf{gpHandshake} and \textsf{gnHandshake} specify the protocol on
%$gp/gp\_ack$
%and $gn/gn\_ack$ interfaces respectively;
%\textsf{noShortcircuit} enforces a safety constraint to prevent a shortcircuit;
%\textsf{ocFunc} and \textsf{ocReact} define the interplay with OC condition;
%and \textsf{environment} captures the fact that OC and UV conditions never
%happen at the same time.
%
%Note that the sequence of PMOS/NMOS switching during the charging cycle is the
%same
%for all operating modes, and therefore the \textsf{chargeFunc} concept can be
%reused
%in other scenarios.
%
%\begin{figure}[H]
%%\vspace{-3mm}
%\begin{centering}
%\includegraphics[scale=0.23]{Images/stg-UV_without_ZC}
%\par\end{centering}
%\protect\caption{\label{fig:zcAbsentScenario STG} STG for the
%\textsf{zcAbsentScenario} concept.}
%\end{figure}
%
%The \textsf{zcAbsentScenario} concept is automatically translated to the STG
%specification
%in Figure~\ref{fig:zcAbsentScenario STG}.
%
%\subsubsection{ZC~late scenario}
%
%
%If ZC condition is detected after UV, then buck operation is the same as in
%absence of ZC, i.e. ZC conditions can be ignored. This is captured by an
%additional
%\textsf{zcLate} concept:
%
%%\vspace{-4mm}
%\[
%\mathsf{zcLateScenario}(uv,oc,zc,gp,gp\_ack,gn,gn\_ack)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%\]
%%\vspace{-6mm}
%\[
%~~=~\mathsf{chargeFunc}~\diamond~\mathsf{uvFunc}~\diamond~\mathsf{uvReact}~\diamond~\mathsf{zcLate}
%\]
%%\vspace{-5mm}
%\[
%\begin{array}{lcl}
%\mathsf{where}&~&\\
%
%~~~~\mathsf{zcLate}&\hspace{-2mm}=&\hspace{-2mm}uv^{+}\rightsquigarrow
%zc^{+}~\diamond~ zc^{-}\rightsquigarrow uv^{-}~~~~~~~~~~~~~~~~~~~~~~~~~~~
%
%\end{array}
%\]
%
%The STG specification automatically produced from the \textsf{zcLateScenario}
%concept
%is shown in Figure~\ref{fig:zcLateScenario STG}. It looks similar to the STG in
%Figure~\ref{fig:zcAbsentScenario STG} but features a concurrent branch for $zc$
%signal.
%Note that the arc $zc^{+}\rightsquigarrow zc^{-}$ is implied at translation
%time by consistency loops.
%
%\begin{figure}[H]
%\begin{centering}
%%\vspace{-1mm}
%\includegraphics[scale=0.23]{Images/stg-UV_before_ZC}
%\par\end{centering}
%%\vspace{-1mm}
%\protect\caption{\label{fig:zcLateScenario STG}STG for the
%\textsf{zcLateScenario} concept.}
%%\vspace{-3mm}
%\end{figure}
%
%Note that the concept specification of \textsf{zcLateScenario} reuses most of
%the code from the \textsf{zcAbsentScenario}; in particular, the description of
%the analogue environment does not need to be duplicated, as with the STG
%approach, where the designer needs to redraw the specification from scratch.
%\noun{Workcraft} allows to copy and paste STGs, which mitigates the problem
%somewhat, but duplication and associated design problems remain -- for example,
%if
%the analogue environment needs to be amended, these changes need to be done
%consistently in all scenarios. With concepts, only one definition needs to be
%changed, which increases the productivity of the designer.
%
%\subsubsection{ZC~early scenario}
%
%If ZC condition is detected before UV then it needs to be explicitly
%handled by the control circuit:
%
%%\vspace{-4mm}
%\[
%\mathsf{zcEarlyScenario}(uv,oc,zc,gp,gp\_ack,gn,gn\_ack)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%\]
%%\vspace{-5mm}
%\[
%\begin{array}{lcl}
%~~=~\mathsf{chargeFunc}~\diamond~\mathsf{zcFunc}~\diamond~\mathsf{zcReact}~\diamond~\mathsf{uvFunc'}\\
%~~~\!\diamond~~~~\!\!\mathsf{uvReact'}\\
%\end{array}
%\]
%%\vspace{-4mm}
%\[
%\begin{array}{lcl}
%\mathsf{where}&~&\\
%
%~~~~\mathsf{zcFunc}&\hspace{-2mm}=&\hspace{-2mm}zc^{+}\rightsquigarrow gn^{-}\\
%~~~~\mathsf{zcReact}&\hspace{-2mm}=&\hspace{-2mm}oc^{-}\rightsquigarrow
%zc^{+}~\diamond~gp^{+}\rightsquigarrow zc^{-}\\
%~~~~\mathsf{uvFunc'}&\hspace{-2mm}=&\hspace{-2mm}uv^{+}\rightsquigarrow gp^{+}\\~~~~\mathsf{uvReact'}&\hspace{-2mm}=&\hspace{-2mm}zc^{+}\rightsquigarrow uv^{+}
%\diamond~zc^{-}\rightsquigarrow uv^{-}\\
%&\hspace{-2mm}\diamond&\hspace{-2mm}gp\_ack^{+}\rightsquigarrow uv^{-}
%
%\end{array}
%\]
%
%The obtained STG for the \textsf{zcEarlyScenario} concept is shown
%in Figure~\ref{fig:zcEarlyScenario STG}.
%
%\begin{figure}[H]
%\begin{centering}
%\includegraphics[scale=0.23]{Images/stg-UV_after_ZC}
%\par\end{centering}
%\protect\caption{\label{fig:zcEarlyScenario STG}STG for the
%\textsf{zcEarlyScenario} concept.}
%%\vspace{-3mm}
%\end{figure}
%
%\subsection{Combining the scenarios }
%
%The scenario STGs can now be combined as described in
%Section~\ref{sub:scenario-composition}
%to produce a multi-scenario specification. As buck operating modes are active
%one at a
%time, the control scenarios are combined using the non-deterministic choice
%template.
%
%Figure~\ref{fig:buck STG} shows the resulting STG specification. This can be
%further simplified by merging the common parts of the scenarios, thus producing
%a more compact model similar to that shown in Figure~\ref{fig:Monolithic-buck}.
%
%There is an explicit place in this model which holds a token initially
%and allows any of the scenarios to run. This free-choice place has no
%control over which scenario can run, and only allows one of
%them to run at a time.
%
%%%\vspace{-3mm}
%
%\subsection{Verification and simulation}
%
%To be combinable by our method, the scenario STGs need to satisfy certain
%properties~\cite{Cortadella}:
%\begin{itemize}
%\item Complete State Coding (CSC): each state of the models with different
%behaviour has differing signal encodings to avoid problems during
%synthesis. Note that in most cases it is possible to automatically
%resolve CSC conflicts.
%\item Deadlock freedom: no state is reachable from which no progress can
%be made.
%\item Output persistence: there are no race conditions in the STG (i.e. no
%glitches).
%\item Signal consistency: in any trace the rising and falling transitions of
%each signal alternate.
%\end{itemize}
%These properties can be automatically checked in \noun{Workcraft} using
%the \noun{Mpsat}~\cite{khomenko2004detecting} backend tool.
%It is also possible to verify custom safety properties expressed using
%syntax similar to SystemVerilog Assertions, which is familiar to many
%hardware designers.
%Figure~\ref{fig:custom_assertion} contains an example custom assertion
%\textsf{!($gp$ \&\& $gn$)} that we created for this case study.
%In this we formally verify that there is no shortcircuit in the system, by
%checking that $gp$ and $gn$ are never high at the same time.
%As seen in this image, the property correctly holds, as expected.
%
%\begin{figure}[t]
%\begin{centering}
%\includegraphics[scale=0.23]{Images/stg-buck-scenarios_merged}
%\par\end{centering}
%\begin{centering}
%\protect\caption{\label{fig:buck STG}Complete STG for a buck converter.}
%\par\end{centering}
%%\vspace{-3mm}
%\end{figure}
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.75]{Images/screenshot-custom-assertion}
%\par\end{centering}
%\begin{centering}
%\protect\caption{\label{fig:custom_assertion}Custom verification of no
%shortcircuit.}
%\par\end{centering}
%%\vspace{-3mm}
%\end{figure}
%
%In the event that one of these properties does not hold, unless it can be
%corrected
%automatically, which \noun{Mpsat} can attempt, the combination of scenarios
%fails.
%In this case a problematic concept can be identified and diagnostic information
%is printed out to help a designer correct the issue.
%
%Correctly produced scenarios may not necessarily work as the designer expects,
%and this needs to be validated before using these scenarios
%in any further designs. In addition to formal verification, \noun{Workcraft}
%features a simulation tool,
%and this can be used by a designer to check that the signals can transition
%according to the initial requirements. If the simulation produces
%undesirable results, a designer can work to fix the error of the scenario
%STG, or correct the design at the concept level. The latter is the
%preferable method if the design is to be reused either as a predefined
%concept, or as a scenario in another system.
%
%After all scenarios have been combined, the result will be the STG specificationfor the full system. If each scenario used in the combination process satisfies
%the verification properties, it is possible no errors will exist within the fullspecification. However,  unforeseen errors may be produced
%and thus, it is necessary to verify the resulting specification. This can
%be performed using \noun{Mpsat} as with the scenarios to ensure the same
%properties are held. The simulation tool built into \noun{Workcraft} can also
%be utilised for testing the functionality of a full system specification.
%
%%Like with the scenario models when they have been composed, we need
%%to verify that this model satisfies certain properties after combination
%%of multiple scenarios, as any issues at this stage will cause an implementation%of the model to be wrong and this can cause the model to be unimplementable
%%as an SI circuit.
%%
%%The verification properties we need to satisfy are the same as for
%%scenarios~(see~Section~\ref{sub:Verification-and-simulation}),
%%and are corrected in similar ways, however the corrections can be
%%done within the problematic scenario, by changing, adding or removing
%%one or more concepts to avoid affecting any of the functionality of
%%the whole system, or any of the correctly functioning scenarios.
%%
%%When the full system model satisfies all of the verification properties,
%%we can simulate this model and check that the signals can transition
%%in the order we expect according to the requirements of the system.
%%If this is correct, we can guarantee that this model represents the
%%full system specification, and can now be used in the next step.
%
%%%\vspace{-2.5mm}
%
%\subsection{Synthesis of a speed-independent controller}
%
%%%\vspace{-2.5mm}
%
%The final step in this design flow is to synthesise the STG specification into
%a speed-independent circuit. Synthesis is the process of finding Boolean
%equations
%to calculate the next state of the output signals based on the input signals
%and the current state of the circuit~\cite{Cortadella}. Circuits can be
%synthesised using \noun{Petrify} or \noun{Mpsat}, both of which are
%integrated in \noun{Workcraft}. There are different types of synthesis
%with their own specifics. For example, Figure~\ref{fig:complex-gate-circuit}
%shows the result of \emph{Complex gate} synthesis of the buck STG.
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.3]{Images/complex-gate-circuit-buck}
%\par\end{centering}
%
%\protect\caption{\label{fig:complex-gate-circuit}Complex gate implementation.}
%\end{figure}
%
%Complex-gate synthesis does not use a gate library and yields Boolean functions
%of arbitrary complexity.
%These functions are often too large to be implemented by a single gate available
%in the gate library.
%Unfortunately, breaking up a complex-gate into smaller ones, when performed
%na\"{\i}vely, generally yields
%an incorrect circuit -- this happens due to the delays associated with the
%outputs of the newly introduced gates and can lead to glitches or deadlocks.
%
%In fact, logic decomposition in the context of speed-independent circuits is a
%very difficult problem,
%that cannot always be solved. \noun{Petrify} and \noun{MPSat} backend tools do a
%good job in many situations,
%but occasionally they fail to converge to a solution and a manual intervention
%by the designer is required.
%
%Another type of synthesis is \emph{Technology mapping}. This performs
%\emph{Logic decomposition} and uses a gate library to map the logic only onto
%gates available in the library.
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.3]{Images/circuit-buck-mapped-pfy-wc.pdf}
%\par\end{centering}
%
%\protect\caption{\label{fig:tech-mapped-circuit}Technology mapped
%implementation.}
%\end{figure}
%
%Figure~\ref{fig:tech-mapped-circuit} is the technology mapped implementation.
%The gate labels correspond to the gate names in the library.
%The two inverters are shown with a dotted line through.
%This is because they have the \emph{Zero delay} property expressing the
%assumption that their output wire delays are negligible.
%This is usually unproblematic as long as such input inverters are placed close
%to the main gate;
%this can be enforced during the place-and-route stage.
%
%Within \noun{Workcraft} we can further decompose the implementation of $gp$ into
%two-input gates,
%as shown in Figure~\ref{fig:circuit-buck-deco2}. This is achieved by restricting
%the synthesis
%back end (in this case \noun{Mpsat}) to use the gates with at most two inputs.
%Such 2-input decompositions may be beneficial for designs targeting low
%operating voltages.
%
%\begin{figure}[h]
%\begin{centering}
%\includegraphics[scale=0.3]{Images/circuit-buck-deco2-wc}
%\par\end{centering}
%\protect\caption{\label{fig:circuit-buck-deco2}Technology mapping into 2-input
%gates/latches.}
%\end{figure}
%
%More information on the synthesis of this example can be found in the tutorials
%of the \noun{Workcraft} website~\cite{Workcraft_website}.

%When we have acquired a circuit design via a chosen synthesis type, it needs to be verified to
%ensure that the logic will perform as we expected before the circuit
%is fabricated. To verify this, the circuit is converted into a so-called
%circuit Petri net, using a model for each logic gate and combining
%them by means of read-arcs. By reachability analysis of this Petri
%net one can verify that the corresponding circuit is deadlock-free,
%hazard-free and conforms to the specification~\cite{2008_poliakov_async}.

%%\vspace{-2mm}

%\section{Related work\label{sec:related-work}}
%
%There are several existing methodologies which are similar to the
%one being proposed in this paper, and there are a common set of features between
%these which can be compared.
%In some cases, these cannot be used for asynchronous designs, but some of their
%other key features can still be compared.
%Table~\ref{tab:related_work} contains a comparison of these features.
%
%We have found these related works limited in certain aspects, and we discuss
%this below.
%
%\begin{table*}[t]
%\caption{A comparison of features of related works and the proposed method
%\label{tab:related_work}}
%  \centering
%\begin{tabular}[htb]{| m{2.6cm} | m{2.0cm} | m{1.3cm} | m{1.75cm} | m{1.5cm} |
%m{1.5cm} | m{1.7cm} | m{1.9cm} |}
%  \hline
%Title & \,Asynchronous support & \,Tool support & \,Composition & \,Gate-level &
%\,Event-level & \,Protocol-level & \,Design focus \\ \hline \hline
%Concepts & Yes & Yes & Yes & Yes & Yes & Yes & Little digital \\ \hline
%Balsa & Yes & Yes & No & Yes & No & Yes & Big digital \\ \hline
%Biscotti & Yes & Yes & No & Yes & No & No & Big digital \\ \hline
%Lava & No & Yes & No & Yes & No & Yes & Big digital \\ \hline
%C$\lambda$ash & No & Yes & No & Yes & No & Yes & Big digital \\ \hline
%Snippets & No & No & Yes & No & No & No & Little digital \\ \hline
%DI algebra & Yes & No & Yes & No & Yes & No & Little digital \\ \hline
%Structural design & No & Yes & No & No & No & No & Modular \\ \hline
%  \end{tabular}
%  %\vspace{-3mm}
%\end{table*}
%
%A common approach of designing asynchronous circuits,
%\textbf{Balsa}~\cite{edwards2002balsa}, uses an RTL language to specify
%operations for asynchronous circuits for both big-digital, data featuring
%multiple bits, and little-digital, control systems. A Balsa specification is
%initially converted into a format describing a network of handshake components,
%which can be used for simulation and circuit diagrams. This can then be used in
%synthesis, by mapping handshake components on to library
%components~\cite{van1993handshake}. RTL languages
%are used for synchronous design, and thus designers can adapt to Balsa
%more easily, however specifying a control system can lead to a complicated
%program which can be difficult to
%comprehend, in comparison to the STGs produced in the proposed approach,
%in which signal interactions can be visualised.
%
%\textbf{Biscotti}~\cite{5232351} is an approach which uses a C-style language,
%which can be easy to adapt to as designers are likely to have programming
%experience. It features
%\emph{forever} blocks, in which code runs sequentially, but all these
%blocks run concurrently to each other. This design method starts by
%specifying a circuit which is then
%\emph{compiled} into a Petri-net for verification with existing tools
%including \noun{Workcraft} and if successful, synthesis, similar to our
%approach with conversion of concepts to allow
%use with multiple existing tools based on STGs. Biscotti is aimed at
%designing data-driven asynchronous systems however, and as with Balsa,
%specifying an asynchronous control system is
%difficult, especially as the number of signals involved increases.
%
%\cite{bjesse1998lava} introduces \textbf{Lava}, a Haskell tool. This features
%its own design flow, using predefined functions for structures like logic gates,
%allowing users to define
%functions using these structures. A collection of these functions can be used to
%design a circuit and be verified within Lava, however for steps such as
%simulation and synthesis, Lava
%generates VHDL code to be used by other software. This has similar ideals to
%concepts, allowing users to define functions from predefined structures, which
%can be reused. However,
%Lava is more focussed on designing synchronous circuits for data operations
%featuring wires with multiple bit widths, rather than asynchronous control
%systems. Concepts are also
%focussed on more than just logic gates, and allows definitions both as standard
%and user-defined at multiple levels; signal-, gate-, protocol- and
%scenario-level.
%
%\textbf{C$\lambda$ash}, introduced in~\cite{baaij2009clambdaash}, is also a
%Haskell
%based tool, similar to Lava, focussed on synchronous data circuits.  It has somecross-over features with Lava, such as built-in verification, and the ability
%for
%users to define functions.
%% Note: not sure what you mean: Clash doesn't synthesise asynchronous circuits!
%% C$\lambda$ash, however, uses existing Haskell
%% constructs to directly synthesize as asynchronous operations.
%C$\lambda$ash also features built in synthesis and simulation, avoiding the need
%to export VHDL, however this feature remains. This allows a simpler way of
%specifying synchronous circuits, which may be more natural for designers,
%however Haskell as a language features huge differences to programming languageslike \noun{C}. The idea of a natural description is shared with Concepts,
%but as with Lava, the main focus is on logic gates, and other high level
%descriptions, where as Concepts allow multiple levels, from low to high, when
%specifying.
%
%\textbf{Snippets}~\cite{raey}, similar to concepts, are smaller
%state graph models which are used to compose full state graphs of
%larger systems. Snippets describe the operation of a part of a system
%in terms of input and output alphabets, and in which ways these snippets
%can fail. When composed with other snippets it can produce a working
%system state graph model. With our design methodology however we want
%to go deeper and decompose a component into concepts responsible for
%capturing signal behaviours for system features, such as handshakes,
%mutual exclusion, synchronisation, etc.
%
%\textbf{DI algebra}~\cite{josephs1993overview} is a method of describing
%systems as algebraic equations. Each equation represents an operation
%of the specification, similar to scenarios, and composing these can
%be simplified for the most compact version of the equation. These
%can then be composed to find an equation for the whole specification
%and again simplified for the most compact version. Our method is similar
%to DI algebra, however concepts are described textually, which is
%different to DI algebra and as such, simplification does not occur
%at concept level, but during the composition and combination steps,
%and the most compact form of the model is automatically produced.
%To the best of our knowledge there are no tools or methodologies supporting
%compositional design of asynchronous circuits using DI algebra and
%it is therefore not interoperable with the rest of our design flow,
%and this also makes it unsuitable for use in an industrial setting.
%
%\textbf{Structural design} features re-usability of modular
%components~\cite{modular-circuit-design}.
%Here, a component design can be used multiple times across full device
%designs in conjunction with several other circuit modules. These modules
%can be changed in some way without affecting how they are used in
%the full device designs. The ideas of this method are similar to that
%of the design methodology we are proposing to reduce design time.
%However, this method is at a much higher level, using fully designed
%and tested components where as we propose to allow re-usability when
%modelling at circuit level, using composed concepts.
%
%Concepts have many advantageous features, such as reuse, natural description,
%multiple level description and composition, and more.
%Several of these approaches feature similar ideas which make them beneficial in
%certain ways,
%but we believe fall down where the inclusion of one or more of these features
%could make an approach better. With concepts,
%we have attempted to address these issues and make concepts not only a powerful
%tool to specify asynchronous circuits, but a method with as much ease-of-use as
%possible, particularly targeting the little-digital design domain.
%Concepts are also supported by industrial-strength open-source software
%toolsuite \noun{Workcraft}.
%
%%\textbf{Resynthesis}~\cite{Resynth2} is a process of decomposing
%%a full model and recomposing it of selective components to produce
%%a smaller model. This can be used to reduce the number of signals
%%to connect two separate models for example. This process is regularly
%%used for optimisation of Balsa control circuits~\cite{plana2005attacking},
%%however in Balsa the set of predefined components is fixed, so a designer
%%cannot easily introduce new scenarios. Resynthesis also requires full
%%models which can be decomposed. This requirement may be problematic
%%for the proposed methodology as we take a ground-up approach to composition,
%%starting with primitive concepts which composed into scenarios, which
%%are subsequently combined into a complete model. Resynthesis can still
%%be used at a later stage of the design process, once the complete
%%model of a system~(or a subsystem) has been obtained using the proposed
%%methodology.


%\vspace{-3mm}

\section{Conclusions and future work\label{sec:conclusions}}


In this work we show that it is possible to design asynchronous control
circuits at the interface between analogue and digital worlds by
splitting their specification into operational modes, scenarios, and
describing signal interactions and requirements of each scenario using
high-level asynchronous concepts. These can then be translated into STGs
that represent these operational modes, which can be used with existing
verification and synthesis tools. STGs can be further combined to
produce a complete model for the system specification.

In this work, we show some more possibilites available when desingning
asynchronous control circuits using concepts. OR-causality can be a
useful tool to include in a circuit, and providing a seemless method
of translation of both this, and the more common AND-causality allows
for concepts to be used in the design of a wider range of asynchronous 
circuits.

Using concepts, a user can reduce the time of designing an asynchronous
control circuit from the ground up, as well as allow reuse of components
either as part of a scenario or entire scenarios to reduce the design-time
of future projects. Composition of concepts and scenarios can help
reduce errors and save time in comparison to performing these manually.
This method can help to make asynchronous circuits more appealing
to industrial designers.

Currently, this method works with Signal Transition Graphs, however
it can be applied to other modelling disciplines, such as Finite State
Machines~(FSM).

\emph{Process mining} can also be used for various purposes in conjunction
with designing asynchronous circuits. For example, process mining can discover
a behavioural model when none currently exists, and can be used to check 
that an existing specification is realistic, or find less complex models. 
All of this can be performed automatically, by tools such as
\noun{PGminer}~\cite{mokhov2016mining}, given
an event log with observations of a real analogue or digital system, and aid a
designer in reducing design time and errors. We aim to test the possibility of producing
concepts directly from the mining of these event logs.

The translations tool we have discussed is available from~\cite{2016_concepts_github},
and as stated, is integrated into \noun{Workcraft}~\cite{Workcraft_website}. 
A manual is included with the tool, which features descriptions of the features. 
We host a regularly updated blog which discusses some interesting properties
of concepts, and new ideas we find for concepts, and this is available 
at~\cite{2016_blog_concepts}.

% We aim to test concepts using examples from several different areas where
% asynchronous circuits are beneficial.
% These will be of various sizes, featuring differing numbers of signals, in an
%attempt to find problematic areas of the concepts design methodology.
% We can then use this information to imporove concepts.

%As the Internet-of-Things becomes ubiquitous, asynchronous circuits
%will be key in designing energy-efficient and reliable IoT nodes,
%particularly at the interfaces between analogue and digital domains,
%such as power management units. We believe that high-level asynchronous
%concepts could be instrumental in the design of these systems.

%CPOG and Parameterised Graph models are also integrated into
%\noun{Workcraft}~\cite{Workcraft_website} as part of the \noun{Scenco}
%toolsuite~\cite{2015_workcraft_scenco}~\cite{Scenco_paper},
%allowing circuits to be described by algebraic equations in text
%form. \noun{Scenco} provides support for describing concept models
%to produce scenarios and then compose scenarios to produce full system
%implementations.

%In certain cases, an implementation may need to be changed based on
%design parameters to produce the best result, and these may change
%during run-time or after the fabrication stage. CPOGs support parameter
%and run-time reconfigurability~\cite{microadapt}, hence if
%design parameters change, the design does not need to be recomposed
%from another list of concepts, thus saving time. For this reason,
%CPOGs could work very well with this design approach.


%
%In certain cases, an implementation may need to be changed based on
%design parameters to produce the best result, and these may change
%during run-time or after the fabrication stage. CPOGs support parameter
%and run-time reconfigurability~\cite{microadapt}, hence if
%design parameters change, the design does not need to be recomposed
%from another list of concepts, thus saving time. For this reason,
%CPOGs could work very well with this design approach.

%STGs and CPOGs both have their benefits when working with asynchronous
%systems, and it will be useful to compare these two methods, to see
%if either is better when designing a system from concepts, or see
%if there are certain specifications where one modelling method is
%better than the other. It may be necessary to have a form of interaction
%between CPOGs and STGs in order to provide a more streamlined method of
%designing asynchronous circuits
%using concepts, and this is something we aim to explore.

%%\vspace{-2mm}

%
%In addition to FSMs and STGs, we also plan to extend this design method
%to support Conditional Partial Order Graphs~(CPOGs)~\cite{CPOG1}
%and Parameterised Graphs~\cite{mokhov2014algebra} for modelling
%asynchronous circuits. These models are also integrated into \noun{Workcraft}
%as part of the \noun{Scenco} toolsuite\noun{~\cite{2015_workcraft_scenco},
%}allowing circuits to be described by algebraic equations in text
%form. \noun{Scenco} provides support for describing concept models
%to produce scenarios and then compose scenarios to produce full system
%implementations.
%
%CPOGs can also be used for process mining, using tools such as
%\noun{PGminer}~\cite{mokhov_2016_mining, pgminer}.
%%Process mining can be used for various purposes in conjunction with designing
%asynchronous circuits. For example, process mining can find a behavioural model
%if non exists, and can be
%%used to check that an existing specification is realistic, or find less complex
%model. All of this can be performed automatically, and aid a designer in
%reducing design time and errors.
%

%%\vspace{-3mm}

%\section*{Acknowledgements}
%
%%%\vspace{-2.5mm}
%
%The authors would like to thank the reviewers for their constructive
%comments. This research is supported by EPSRC research grant `A4A:
%Asynchronous design for Analogue electronics' (EP/L025507/1) and
%the Royal Society research grant `Computation Alive: Design of a
%Processor with Survival Instincts'.

%%\vspace{-2.5mm}

\bibliographystyle{unsrt}
\bibliography{publications}

\end{document}
